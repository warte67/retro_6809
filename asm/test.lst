                      ; test.asm
                      ;
                      
0000                                  INCLUDE "Kernel_Header.asm"
                      ; ***** kernel_header.asm ************************************************************************
                      ; *      _  __                    _     _   _                _
                      ; *     | |/ /___ _ __ _ __   ___| |   | | | | ___  __ _  __| | ___ _ __    __ _ ___ _ __ ___
                      ; *     | ' // _ \ '__| '_ \ / _ \ |   | |_| |/ _ \/ _` |/ _` |/ _ \ '__|  / _` / __| '_ ` _ \
                      ; *     | . \  __/ |  | | | |  __/ |   |  _  |  __/ (_| | (_| |  __/ |_   | (_| \__ \ | | | | |
                      ; *     |_|\_\___|_|  |_| |_|\___|_|___|_| |_|\___|\__,_|\__,_|\___|_(_)   \__,_|___/_| |_| |_|
                      ; *                               |_____|
                      ; *
                      ; ************************************************************************************************
                      
0000                                      INCLUDE "Memory_Map.asm"
                      ;*** Memory_Map.asm *************************************************
                      ;*    __  __                                     __  __                                 
                      ;*   |  \/  |                                   |  \/  |                                
                      ;*   | \  / | ___ _ __ ___   ___  _ __ _   _    | \  / | __ _ _ __   __ _ ___ _ __ ___  
                      ;*   | |\/| |/ _ \ '_ ` _ \ / _ \| '__| | | |   | |\/| |/ _` | '_ \ / _` / __| '_ ` _ \ 
                      ;*   | |  | |  __/ | | | | | (_) | |  | |_| |   | |  | | (_| | |_) | (_| \__ \ | | | | |
                      ;*   |_|  |_|\___|_| |_| |_|\___/|_|   \__, |   |_|  |_|\__,_| .__(_)__,_|___/_| |_| |_|
                      ;*                                      __/ |_____           | |                        
                      ;*                                     |___/______|          |_|                        
                      ;*
                      ;* 6809 Assembly Memory Map Definition File
                      ;*
                      ;* Released under the GPL v3.0 License.
                      ;* Original Author: Jay Faries (warte67)
                      ;*
                      ;************************************
                      
                      
                      
                      ;   **********************************************
                      ;   * Allocated 64k Memory Mapped System Symbols *
                      ;   **********************************************
                      ;
                      
0000                  SOFT_VECTORS_DEVICE   equ    $0000    ; START: Software Interrupt Vectors
0000                  SOFT_EXEC             equ    $0000    ; Exec Software Interrupt Vector
0002                  SOFT_SWI3             equ    $0002    ; SWI3 Software Interrupt Vector
0004                  SOFT_SWI2             equ    $0004    ; SWI2 Software Interrupt Vector
0006                  SOFT_FIRQ             equ    $0006    ; FIRQ Software Interrupt Vector
0008                  SOFT_IRQ              equ    $0008    ; IRQ Software Interrupt Vector
000A                  SOFT_SWI              equ    $000A    ; SWI / SYS Software Interrupt Vector
000C                  SOFT_NMI              equ    $000C    ; NMI Software Interrupt Vector
000E                  SOFT_RESET            equ    $000E    ; RESET Software Interrupt Vector
                      ; _______________________________________________________________________
                      
0010                  SYSTEM_MEMORY_DEVICE  equ    $0010    ; START: System Memory
0010                  ZERO_PAGE             equ    $0010    ; Zero Page System and User Variables
00FF                  ZERO_PAGE_END         equ    $00FF    ; Zero Page System and User Variables
0100                  EDT_BUFFER            equ    $0100    ; START: Line Edit Character Buffer
017F                  KEY_END               equ    $017F    ; END: Line Edit Character Buffer
0180                  FIO_BUFFER            equ    $0180    ; START: Input/Output Buffer
01FF                  FIO_BFR_END           equ    $01FF    ; END: Input/Output Buffer
0200                  SYSTEM_STACK          equ    $0200    ; Bottom of System Stack Spcace
03FF                  SSTACK_END            equ    $03FF    ; END: System Stack Space
0400                  SSTACK_TOP            equ    $0400    ; TOP: System Stack Space
                      ; _______________________________________________________________________
                      
0400                  VIDEO_BUFFER_DEVICE   equ    $0400    ; START: Video Buffer (8K)
0400                  VIDEO_START           equ    $0400    ; Start of standard video buffer
23FF                  VIDEO_END             equ    $23FF    ; End of standard video buffer
2400                  VIDEO_TOP             equ    $2400    ; Top of standard video buffer
                      ; _______________________________________________________________________
                      
2400                  USER_MEMORY_DEVICE    equ    $2400    ; START: User Memory (34K)
2400                  USER_RAM              equ    $2400    ; User Accessable RAM
AFFF                  USER_RAM_END          equ    $AFFF    ; End User Accessable RAM
B000                  USER_RAM_TOP          equ    $B000    ; Top User Accessable RAM
                      ; _______________________________________________________________________
                      
B000                  BANKED_MEMORY_REGION  equ    $B000    ; START: Banked Memory Region (16K)
B000                  BANKMEM_ONE           equ    $B000    ; Banked Memory Page One (8K)
D000                  BANKMEM_TWO           equ    $D000    ; Banked Memory Page Two (8K)
EFFF                  BANKMEM_END           equ    $EFFF    ; End of Banked Memory Region
F000                  BANKMEM_TOP           equ    $F000    ; TOP of Banked Memory Region
                      ; _______________________________________________________________________
                      
F000                  KERNEL_ROM_DEVICE     equ    $F000    ; START: Kernel Rom (3.5K)
F000                  KERNEL_START          equ    $F000    ; Start of Kernel Rom Space
FDFF                  KERNEL_END            equ    $FDFF    ; End of Kernel Rom Space
FE00                  KERNEL_TOP            equ    $FE00    ; Top of Kernel Rom Space
                      ; _______________________________________________________________________
                      
FE00                  SYS_DEVICE            equ    $FE00    ; START: System and Debug Hardware Registers:
FE00                  SYS_BEGIN             equ    $FE00    ; Start of System Registers
FE00                  SYS_STATE             equ    $FE00    ; (Byte) System State Register
                                                            ; SYS_STATE: ABCD.SSSS                          
                                                            ; - bit  7   = Error: Standard Buffer Overflow  
                                                            ; - bit  6   = Error: Extended Buffer Overflow  
                                                            ; - bit  5   = Error: Reserved                  
                                                            ; - bit  4   = Error: Reserved                  
                                                            ; - bits 0-3 = CPU Speed (0-15):                
                                                            ;    0 ($0)  = CPU Clock   10 kHz 
                                                            ;    1 ($1)  = CPU Clock   25 kHz 
                                                            ;    2 ($2)  = CPU Clock   50 kHz 
                                                            ;    3 ($3)  = CPU Clock   75 kHz 
                                                            ;    4 ($4)  = CPU Clock  100 kHz 
                                                            ;    5 ($5)  = CPU Clock  150 kHz 
                                                            ;    6 ($6)  = CPU Clock  225 kHz 
                                                            ;    7 ($7)  = CPU Clock  350 kHz 
                                                            ;    8 ($8)  = CPU Clock  500 kHz 
                                                            ;    9 ($9)  = CPU Clock  750 kHz 
                                                            ;   10 ($A)  = CPU Clock  900 kHz 
                                                            ;   11 ($B)  = CPU Clock 1000 khz 
                                                            ;   12 ($C)  = CPU Clock 2000 khz 
                                                            ;   13 ($D)  = CPU Clock 3000 khz 
                                                            ;   14 ($E)  = CPU Clock 4000 khz 
                                                            ;   15 ($F)  = CPU Clock ~10.0 mhz. (unmetered) 
                                                            ; 
FE01                  SYS_SPEED             equ    $FE01    ; (Word) Average CPU Clock Speed (Read Only)
FE03                  SYS_CLOCK_DIV         equ    $FE03    ; (Byte) 60 hz Clock Divider Register (Read Only)
                                                            ; - bit 7: 0.546875 hz
                                                            ; - bit 6: 1.09375 hz
                                                            ; - bit 5: 2.1875 hz
                                                            ; - bit 4: 4.375 hz
                                                            ; - bit 3: 8.75 hz
                                                            ; - bit 2: 17.5 hz
                                                            ; - bit 1: 35.0 hz
                                                            ; - bit 0: 70.0 hz
                                                            ; 
FE04                  SYS_UPDATE_COUNT      equ    $FE04    ; (DWord) Update Count (Read Only)
FE08                  SYS_DBG_BRK_ADDR      equ    $FE08    ; (Word) Address of current debug breakpoint
FE0A                  SYS_DBG_FLAGS         equ    $FE0A    ; (Byte) Debug Specific Hardware Flags:
                                                            ; - bit 7: Debug Enable
                                                            ; - bit 6: Single Step Enable
                                                            ; - bit 5: Clear All Breakpoints
                                                            ; - bit 4: Update Breakpoint at DEBUG_BRK_ADDR
                                                            ; - bit 3: FIRQ  (on low {0} to high {1} edge)
                                                            ; - bit 2: IRQ   (on low {0} to high {1} edge)
                                                            ; - bit 1: NMI   (on low {0} to high {1} edge)
                                                            ; - bit 0: RESET (on low {0} to high {1} edge)
                                                            ; 
FE0A                  SYS_END               equ    $FE0A    ; End of System Registers
FE0B                  SYS_TOP               equ    $FE0B    ; Top of System Registers
                      ; _______________________________________________________________________
                      
FE0B                  GPU_DEVICE            equ    $FE0B    ; START: GPU Device Hardware Registers
FE0B                  GPU_MODE              equ    $FE0B    ; 
FE0B                  GPU_MODE_MSB          equ    $FE0B    ; (Byte) Graphics Display Mode
                                                            ; - bit  7   = Extended Display Enable:
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bit  6   = (reserved)
                                                            ; - bits 4-5 = Extended Color Depth:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bit  3   = Extended Rendering Mode
                                                            ;               0: Tilemap Display
                                                            ;               1: Bitmap Display
                                                            ; - bit  2   = Emulation Screen Mode
                                                            ;               0: Windowed
                                                            ;               1: Fullscreen
                                                            ; - bit  1   = VSync Enable
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bit  0   = Presentation
                                                            ;               0: Letterbox
                                                            ;               1: Overscan / Stretch
                                                            ; 
FE0C                  GPU_MODE_LSB          equ    $FE0C    ; - bit  7   = Standard Display Enable
                                                            ;              0: Disabled
                                                            ;              1: Enabled
                                                            ; - bit  6    = (reserved)
                                                            ; - bits 4-5 = Standard Bitmap Color Depth:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bit  3    = Standard Bitmap:
                                                            ;               0: Text Display
                                                            ;               1: Bitmap Display
                                                            ; MODE (bits 0-2):
                                                            ; - bit  2    = 0: 320/256 width,  1: 160/128 width
                                                            ; - bit  1    = 0: 200/160 height, 1: 160/80 height
                                                            ; - bit  0    = Base Resolution: 0:320x200, 1:256x160
                                                            ; 
                                                            ;               Text Mode Table:
                                                            ;    | MODE | COLUMNS |  ROWS  | BUFFER |
                                                            ;    |:----:|:-------:|:------:|:------:|
                                                            ;    |  $00 |    40   |   25   |  2000  |
                                                            ;    |  $01 |    32   |   20   |  1280  |
                                                            ;    |  $02 |    40   |   12   |   960  |
                                                            ;    |  $03 |    32   |   10   |   640  |
                                                            ;    |  $04 |    20   |   25   |  1000  |
                                                            ;    |  $05 |    16   |   20   |   640  |
                                                            ;    |  $06 |    20   |   12   |   480  |
                                                            ;    |  $07 |    16   |   10   |   320  |
                                                            ; 
                                                            ;         Bitmap Display Mode Table:
                                                            ; | MODE | WIDTH | HEIGHT | COLORS | BUFFER |
                                                            ; |------|-------|--------|--------|--------|
                                                            ; | $00  |  320  |   200  |    2   |  8000  |
                                                            ; | $01  |  256  |   160  |    2   |  5120  |
                                                            ; | $02  |  320  |   100  |    2   |  4000  |
                                                            ; | $03  |  256  |    80  |    2   |  2560  |
                                                            ; | $04  |  160  |   200  |    2   |  4000  |
                                                            ; | $05  |  128  |   160  |    2   |  2560  |
                                                            ; | $06  |  160  |   100  |    2   |  2000  |
                                                            ; | $07  |  128  |    80  |    2   |  1280  |
                                                            ; | $00  |  320  |   200  |    4   | 16000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |    4   | 10240  | (bgnd only)
                                                            ; | $02  |  320  |   100  |    4   |  8000  |
                                                            ; | $03  |  256  |    80  |    4   |  5120  |
                                                            ; | $04  |  160  |   200  |    4   |  8000  |
                                                            ; | $05  |  128  |   160  |    4   |  5120  |
                                                            ; | $06  |  160  |   100  |    4   |  4000  |
                                                            ; | $07  |  128  |    80  |    4   |  2560  |
                                                            ; | $00  |  320  |   200  |   16   | 32000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |   16   | 20480  | (bgnd only)
                                                            ; | $02  |  320  |   100  |   16   | 16000  | (bgnd only)
                                                            ; | $03  |  256  |    80  |   16   | 10240  | (bgnd only)
                                                            ; | $04  |  160  |   200  |   16   | 16000  | (bgnd only)
                                                            ; | $05  |  128  |   160  |   16   | 10240  | (bgnd only)
                                                            ; | $06  |  160  |   100  |   16   |  8000  |
                                                            ; | $07  |  128  |    80  |   16   |  5120  |
                                                            ; | $00  |  320  |   200  |  256   | 64000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |  256   | 40960  | (bgnd only)
                                                            ; | $02  |  320  |   100  |  256   | 32000  | (bgnd only)
                                                            ; | $03  |  256  |    80  |  256   | 20480  | (bgnd only)
                                                            ; | $04  |  160  |   200  |  256   | 32000  | (bgnd only)
                                                            ; | $05  |  128  |   160  |  256   | 20480  | (bgnd only)
                                                            ; | $06  |  160  |   100  |  256   | 16000  | (bgnd only)
                                                            ; | $07  |  128  |    80  |  256   | 10240  | (bgnd only)
                                                            ; 
FE0D                  GPU_VIDEO_MAX         equ    $FE0D    ; (Word) Video Buffer Maximum (Read Only)
                                                            ; Note: This will change to reflect
                                                            ;       the size of the last cpu
                                                            ;       accessible memory location
                                                            ;       of the currently active
                                                            ;       standard video mode.
                                                            ; 
FE0F                  GPU_HRES              equ    $FE0F    ; (Word) Horizontal Pixel Resolution (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       pixel columns for bitmap modes.
                                                            ; 
FE11                  GPU_VRES              equ    $FE11    ; (Word) Vertical Pixel Resolution (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       pixel rows for bitmap modes.
                                                            ; 
FE13                  GPU_TCOLS             equ    $FE13    ; (Byte) Text Horizontal Columns (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       glyph columns for text modes.
                                                            ; 
FE14                  GPU_TROWS             equ    $FE14    ; (Byte) Text Vertical Rows (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       glyph rows for text modes.
                                                            ; 
FE15                  GPU_PAL_INDEX         equ    $FE15    ; (Byte) Color Palette Index
                                                            ; Note: Use this register to set the
                                                            ;       index into the Color Palette.
                                                            ;       Set this value prior referencing
                                                            ;       the color data (GPU_PAL_COLOR).
                                                            ; 
FE16                  GPU_PAL_COLOR         equ    $FE16    ; (Word) Color Palette Data (A4R4G4B4 format)
                                                            ; Note: This is the color data for an
                                                            ;       individual palette entry. Write to 
                                                            ;       DSP_PAL_IDX with the index within the
                                                            ;       color palette prior to reading or
                                                            ;       writing the color data in the
                                                            ;       GFX_PAL_CLR register.
                                                            ; 
FE18                  GPU_GLYPH_IDX         equ    $FE18    ; (Byte) Text Glyph Index
                                                            ; Note: Use this register to set the
                                                            ;       index of a specific text glyph.
                                                            ;       Set this value prior to updating
                                                            ;       the glyph data (GPU_GLYPH_DATA).
                                                            ; 
FE19                  GPU_GLYPH_DATA        equ    $FE19    ; (8-Bytes) 8 rows of binary encoded glyph pixel data
                                                            ; Note: This is the pixel data for a
                                                            ;       specific text glyph. Each 8x8
                                                            ;       text glyph is composed of 8 bytes.
                                                            ;       The first byte in this array
                                                            ;       represents the top line of 8 pixels.
                                                            ;       Each array entry represents a row of 8 pixels.
                                                            ; 
FE21                  GPU_BGND_SIZE         equ    $FE21    ; (Word) Extended Graphics Buffer Size (Read Only)
                                                            ; Note: The primary extended graphics buffer
                                                            ;       always begins at $0000. This is also highest
                                                            ;       accessible memory location of the currently
                                                            ;       active background video mode.
                                                            ; 
FE23                  GPU_BLIT_ADDR         equ    $FE23    ; (Word) Graphics Memory Address Port 
                                                            ; Note: When GPU_BLIT_DATA is accessed, this register
                                                            ;       is automatically incremented to point to the  
                                                            ;       next byte to be read or written based on the 
                                                            ;       values in GPU_BLIT_PITCH and GPU_BLIT_WIDTH.
                                                            ; 
FE25                  GPU_BLIT_PITCH        equ    $FE25    ; (Word) Number of Bytes Per Display Line
                                                            ; Note: This value represents the number of displayed
                                                            ;       pixels per line.
                                                            ; 
FE27                  GPU_BLIT_WIDTH        equ    $FE27    ; (Word) Width of the Image Block in Pixels
FE29                  GPU_BLIT_DATA         equ    $FE29    ; (Byte) GPU Memory Data Port
                                                            ; 
FE2A                  GPU_CMD_ARG_1         equ    $FE2A    ; (Word) GPU Command Argument 1
FE2C                  GPU_CMD_ARG_2         equ    $FE2C    ; (Word) GPU Command Argument 2
FE2E                  GPU_CMD_ARG_3         equ    $FE2E    ; (Word) GPU Command Argument 3
FE30                  GPU_CMD_ARG_4         equ    $FE30    ; (Word) GPU Command Argument 4
FE32                  GPU_CMD_ARG_5         equ    $FE32    ; (Word) GPU Command Argument 5
                                                            ; 
FE34                  GPU_COMMAND           equ    $FE34    ; (Byte) Memory Management Unit Command:
                                                            ; 
0000                  GPU_CMD_NOP           equ    $0000    ;    $00 = No Operation / Error
0001                  GPU_CMD_SIZE          equ    $0001    ;    $01 = Total Number of MMU Commands
                                                            ; 
FE35                  GPU_BMP_IDX           equ    $FE35    ; (Byte) Bitmap Image Index (0-255)
FE36                  GPU_BMP_OFFSET        equ    $FE36    ; (Byte) Offset Within the Image Buffer    (0-255)
FE37                  GPU_BMP_DATA          equ    $FE37    ; (Byte) Bitmap Data      (Read Write)
                                                            ; 
FE38                  GPU_SPR_XPOS          equ    $FE38    ; (Sint16) Sprite X Position
FE3A                  GPU_SPR_YPOS          equ    $FE3A    ; (Sint16) Sprite X Position
FE3C                  GPU_SPR_FLAGS         equ    $FE3C    ; (Byte) Sprite Flags:
                                                            ; 
0001                  GPU_SPR_FL_DBL_WIDTH  equ    $0001    ;    % 0000'0001:  Double Width
0002                  GPU_SPR_FL_DBL_HEIGHT equ    $0002    ;    % 0000'0010:  Double Height
0004                  GPU_SPR_FL_FLP_HORIZ  equ    $0004    ;    % 0000'0100:  Flip Horizontal
0008                  GPU_SPR_FL_FLP_VERT   equ    $0008    ;    % 0000'1000:  Flip Vertical
                                                            ;    % 0011'0000:  Collision Type:
0000                  GPU_SPR_FL_COL_NONE   equ    $0000    ;         00 = none
0001                  GPU_SPR_FL_COL_BNDS   equ    $0001    ;         01 = bounding box
0002                  GPU_SPR_FL_COL_CNTR   equ    $0002    ;         10 = center box
0003                  GPU_SPR_FL_COL_PXL    equ    $0003    ;         11 = pixel mask
0040                  GPU_SPR_FL_SPR_ENABLE equ    $0040    ;    % 0100'0000:  Sprite Enable
0080                  GPU_SPR_FL_RESERVED   equ    $0080    ;    % 1000'0000:  (reserved)
                                                            ; 
FE3D                  GPU_IMG_FLAGS         equ    $FE3D    ; (Byte) Image Flags:
                                                            ; 
0003                  GPU_IMG_COLOR_MODE    equ    $0003    ;    % 0000'0011:  Color Mode:
0000                  GPU_IMG_FL_2_COLORS   equ    $0000    ;         00 = 2-colors
0001                  GPU_IMG_FL_4_COLORS   equ    $0001    ;         01 = 4-colors
0002                  GPU_IMG_FL_16_COLORS  equ    $0002    ;         10 = 16-colors
0003                  GPU_IMG_FL_256_COLORS equ    $0003    ;         11 = 256-colors
0004                  GPU_IMG_FL_SEC_PAL    equ    $0004    ;    % 0000'0100:  Secondary Palette (rules apply)
0008                  GPU_IMG_FL_32_WIDTH   equ    $0008    ;    % 0000'1000:  32 pixel width (rules apply)
0010                  GPU_IMG_FL_32_HEIGHT  equ    $0010    ;    % 0001'0000:  32 pixel height (rules apply)
00E0                  GPU_IMG_FL_DBL_WIDTH  equ    $00E0    ;    % 1110'0000:  (reserved)
                                                            ; 
FE3E                  GPU_TMAP_WIDTH        equ    $FE3E    ; (Word) Tilemap Width (in pixels)
FE40                  GPU_TMAP_HEIGHT       equ    $FE40    ; (Word) Tilemap Height (in pixels)
FE42                  GPU_TMAP_XPOS         equ    $FE42    ; (SInt16) Tilemap X Position (top left corner)
FE44                  GPU_TMAP_YPOS         equ    $FE44    ; (SInt16) Tilemap Y Position (top left corner)
FE46                  GPU_TMAP_CLIP_X1      equ    $FE46    ; (Word) Tilemap Clip Region X1
FE48                  GPU_TMAP_CLIP_Y1      equ    $FE48    ; (Word) Tilemap Clip Region Y1
FE4A                  GPU_TMAP_CLIP_X2      equ    $FE4A    ; (Word) Tilemap Clip Region X2
FE4C                  GPU_TMAP_CLIP_Y2      equ    $FE4C    ; (Word) Tilemap Clip Region Y2
                                                            ; 
FE4E                  GPU_ERROR             equ    $FE4E    ; (Byte) Graphics Processing Unit Error Code:     (Read Only)
0000                  GPU_ERR_NONE          equ    $0000    ;    $00 = No Error
0001                  GPU_ERR_COMMAND       equ    $0001    ;    $01 = Invalid Command
0002                  GPU_ERR_ADDRESS       equ    $0002    ;    $02 = Invalid Address
0003                  GPU_ERR_HANDLE        equ    $0003    ;    $03 = Invalid Handle
0004                  GPU_ERR_WIDTH         equ    $0004    ;    $04 = Invalid Width
0005                  GPU_ERR_HEIGHT        equ    $0005    ;    $05 = Invalid Height
0006                  GPU_ERR_PITCH         equ    $0006    ;    $06 = Invalid Pitch
0007                  GPU_ERR_DATA          equ    $0007    ;    $07 = Invalid Data
0008                  GPU_ERR_OFFSET        equ    $0008    ;    $08 = Invalid Offset
0009                  GPU_ERR_ARGUMENT      equ    $0009    ;    $09 = Invalid Argument
000A                  GPU_ERR_OOM           equ    $000A    ;    $0A = Out of Memory
000B                  GPU_ERR_SIZE          equ    $000B    ;    $0B = Total Number of GPU Errors
                                                            ; 
FE4E                  GPU_END               equ    $FE4E    ; End of GPU Register Space
FE4F                  GPU_TOP               equ    $FE4F    ; Top of GPU Register Space
                      ; _______________________________________________________________________
                      
FE4F                  CSR_DEVICE            equ    $FE4F    ; START: Mouse Device Hardware Registers
FE4F                  CSR_XPOS              equ    $FE4F    ; (Word) Horizontal Mouse Cursor Coordinate
FE51                  CSR_YPOS              equ    $FE51    ; (Word) Vertical Mouse Cursor Coordinate
FE53                  CSR_XOFS              equ    $FE53    ; (Byte) Horizontal Mouse Cursor Offset
FE54                  CSR_YOFS              equ    $FE54    ; (Byte) Vertical Mouse Cursor Offset
FE55                  CSR_SCROLL            equ    $FE55    ; (char) MouseWheel Scroll: -1, 0, 1
FE56                  CSR_FLAGS             equ    $FE56    ; (Byte) Mouse Device State Flags
                                                            ;    bits 0-4: button states
                                                            ;    bits 5-6: number of clicks
                                                            ;    bits 7:   cursor enable
                                                            ; 
FE57                  CSR_BMP_INDX          equ    $FE57    ; (Byte) Mouse Cursor Bitmap Pixel Offset
FE58                  CSR_BMP_DATA          equ    $FE58    ; (Byte) Mouse Cursor Bitmap Pixel Color Data ($0-$F)
FE59                  CSR_PAL_INDX          equ    $FE59    ; (Byte) Mouse Cursor Color Palette Index (0-15)
FE5A                  CSR_PAL_DATA          equ    $FE5A    ; (Word) Mouse Cursor Color Palette Data A4R4G4B4
FE5B                  CSR_END               equ    $FE5B    ; End of Mouse Device Register Space
FE5C                  CSR_TOP               equ    $FE5C    ; Top of CSR Register Space
                      ; _______________________________________________________________________
                      
FE5C                  KEYBOARD_DEVICE       equ    $FE5C    ; START: Keyboard Device Hardware Registers
FE5C                  CHAR_Q_LEN            equ    $FE5C    ; (Byte) Number of Characters Waiting in Queue   (Read Only)
FE5D                  CHAR_SCAN             equ    $FE5D    ; (Byte) Read Next Character in Queue (Not Popped When Read)
FE5E                  CHAR_POP              equ    $FE5E    ; (Byte) Read Next Character in Queue     (Popped When Read)
FE5F                  XKEY_BUFFER           equ    $FE5F    ; (16 Bytes) 128 bits for XK_KEY data buffer     (Read Only)
FE6F                  EDT_BFR_CSR           equ    $FE6F    ; (Byte) Cursor Position Within Edit Buffer     (Read/Write)
FE70                  EDT_ENABLE            equ    $FE70    ; (Byte) Line Editor Enable Flag                (Read/Write)
FE71                  EDT_BFR_LEN           equ    $FE71    ; (Byte) Limit the Line Editor to This Length   (Read/Write)
FE71                  KEYBOARD_END          equ    $FE71    ; End of Keyboard Register Space
FE72                  KEYBOARD_TOP          equ    $FE72    ; Top of Keyboard Register Space
                      ; _______________________________________________________________________
                      
FE72                  JOYSTICK_DEVICE       equ    $FE72    ; START: Joystick/Gamepad Controller Device Hardware Registers
FE72                  JOYS_1_FLAGS          equ    $FE72    ; (Byte) Gamepad/Joystick #1 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE73                  JOYS_1_BTN            equ    $FE73    ; (Word) Gamepad Controller Button Bits:         (Read Only)
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = A
                                                            ;            0000'0000'0000'0010 = B
                                                            ;            0000'0000'0000'0100 = X
                                                            ;            0000'0000'0000'1000 = Y
                                                            ;            0000'0000'0001'0000 = L.Shoulder
                                                            ;            0000'0000'0010'0000 = R.Shoulder
                                                            ;            0000'0000'0100'0000 = Back
                                                            ;            0000'0000'1000'0000 = Start
                                                            ;            0000'0001'0000'0000 = Misc 1
                                                            ;            0000'0010'0000'0000 = Misc 2
                                                            ;            0000'0100'0000'0000 = Misc 3
                                                            ;            0000'1000'0000'0000 = Guide
                                                            ;            0001'0000'0000'0000 = DPad Up   
                                                            ;            0010'0000'0000'0000 = DPad Down 
                                                            ;            0100'0000'0000'0000 = DPad Left 
                                                            ;            1000'0000'0000'0000 = DPad Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE75                  JOYS_1_DBND           equ    $FE75    ; (Byte) PAD 1 analog deadband; default is 5   (read/write)
FE76                  JOYS_1_LTX            equ    $FE76    ; (char) PAD 1 LThumb-X position (-128 _ +127)   (realtime)
FE77                  JOYS_1_LTY            equ    $FE77    ; (char) PAD 1 LThumb-Y position (-128 _ +127)   (realtime)
FE78                  JOYS_1_RTX            equ    $FE78    ; (char) PAD 1 RThumb-X position (-128 _ +127)   (realtime)
FE79                  JOYS_1_RTY            equ    $FE79    ; (char) PAD 1 RThumb-Y position (-128 _ +127)   (realtime)
FE7A                  JOYS_1_Z1             equ    $FE7A    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
FE7B                  JOYS_1_Z2             equ    $FE7B    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
                                                            ; 
FE7C                  JOYS_2_FLAGS          equ    $FE7C    ; (Byte) Gamepad/Joystick #2 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE7D                  JOYS_2_BTN            equ    $FE7D    ; (Word) Button Bits: Room For up to 16 Buttons  (realtime)
                                                            ;        Joystick Button Bits:
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = Button 1 
                                                            ;            0000'0000'0000'0010 = Button 2 
                                                            ;            0000'0000'0000'0100 = Button 3 
                                                            ;            0000'0000'0000'1000 = Button 4 
                                                            ;            0000'0000'0001'0000 = Button 5 
                                                            ;            0000'0000'0010'0000 = Button 6 
                                                            ;            0000'0000'0100'0000 = Button 7 
                                                            ;            0000'0000'1000'0000 = Button 8 
                                                            ;            0000'0001'0000'0000 = Button 9 
                                                            ;            0000'0010'0000'0000 = Button 10
                                                            ;            0000'0100'0000'0000 = Button 11
                                                            ;            0000'1000'0000'0000 = Button 12
                                                            ;            0001'0000'0000'0000 = Hat Up   
                                                            ;            0010'0000'0000'0000 = Hat Down 
                                                            ;            0100'0000'0000'0000 = Hat Left 
                                                            ;            1000'0000'0000'0000 = Hat Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE7F                  JOYS_2_DBND           equ    $FE7F    ; (Byte) PAD 2 analog deadband; default is 5   (read/write)
FE80                  JOYS_2_LTX            equ    $FE80    ; (char) PAD 2 LThumb-X position (-128 _ +127)   (realtime)
FE81                  JOYS_2_LTY            equ    $FE81    ; (char) PAD 2 LThumb-Y position (-128 _ +127)   (realtime)
FE82                  JOYS_2_RTX            equ    $FE82    ; (char) PAD 2 RThumb-X position (-128 _ +127)   (realtime)
FE83                  JOYS_2_RTY            equ    $FE83    ; (char) PAD 2 RThumb-Y position (-128 _ +127)   (realtime)
FE84                  JOYS_2_Z1             equ    $FE84    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE85                  JOYS_2_Z2             equ    $FE85    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE85                  JOYS_END              equ    $FE85    ; End of Joystick/Gamepad Device Register Space
FE86                  JOYS_TOP              equ    $FE86    ; Top of Joystick/Gamepad Device Register Space
                      ; _______________________________________________________________________
                      
FE86                  FIO_DEVICE            equ    $FE86    ; START: File I/O Device Hardware Registers
FE86                  FIO_ERROR             equ    $FE86    ; (Byte) FILE_ERROR enumeration result (FE_<error>)
                                                            ; 
0000                  FE_BEGIN              equ    $0000    ;   Begin FILE_ERROR enumeration 
0000                  FE_NOERROR            equ    $0000    ;      no error, condition normal
0001                  FE_NOTFOUND           equ    $0001    ;      file or folder not found  
0002                  FE_NOTOPEN            equ    $0002    ;      file not open             
0003                  FE_EOF                equ    $0003    ;      end of file               
0004                  FE_OVERRUN            equ    $0004    ;      buffer overrun            
0005                  FE_WRONGTYPE          equ    $0005    ;      wrong file type           
0006                  FE_BAD_CMD            equ    $0006    ;      invalid command           
0007                  FE_BADSTREAM          equ    $0007    ;      invalid file stream       
0007                  FE_NOT_EMPTY          equ    $0007    ;      directory not empty       
0007                  FE_FILE_EXISTS        equ    $0007    ;      file already exists       
0007                  FE_INVALID_NAME       equ    $0007    ;      invalid file name         
0007                  FE_LAST               equ    $0007    ;   End of FILE_ERROR enumeration
                                                            ; 
FE87                  FIO_COMMAND           equ    $FE87    ; (Byte) Execute a File Command (FC_<cmd>)
                                                            ; 
0000                  FC_BEGIN              equ    $0000    ;   Begin FIO_COMMAND enumeration           
0000                  FC_RESET              equ    $0000    ;     Reset                                 
0001                  FC_SHUTDOWN           equ    $0001    ;     SYSTEM: Shutdown                      
0002                  FC_COMPDATE           equ    $0002    ;     SYSTEM: Load Compilation Date         
0003                  FC_FILEEXISTS         equ    $0003    ;     Does File Exist (return in FIO_IODATA)
0004                  FC_OPENREAD           equ    $0004    ;     Open Binary File For Reading          
0005                  FC_OPENWRITE          equ    $0005    ;     Open Binary File For Writing          
0006                  FC_OPENAPPEND         equ    $0006    ;     Open Binary File For Appending        
0007                  FC_CLOSEFILE          equ    $0007    ;     Close File                            
0008                  FC_READBYTE           equ    $0008    ;     Read Byte (into FIO_IOBYTE)           
0009                  FC_WRITEBYTE          equ    $0009    ;     Write Byte (from FIO_IOBYTE)          
000A                  FC_LOADHEX            equ    $000A    ;     Load Hex Format File                  
000B                  FC_GETLENGTH          equ    $000B    ;     Get File Length (into FIO_IOWORD)     
000C                  FC_LISTDIR            equ    $000C    ;     List Directory                        
000D                  FC_MAKEDIR            equ    $000D    ;     Make Directory                        
000E                  FC_CHANGEDIR          equ    $000E    ;     Change Directory                      
000F                  FC_GETPATH            equ    $000F    ;     Fetch Current Path                    
0010                  FC_REN_DIR            equ    $0010    ;     Rename Directory                      
0011                  FC_DEL_DIR            equ    $0011    ;     Delete Directory                      
0012                  FC_DEL_FILE           equ    $0012    ;     Delete File                           
0013                  FC_REN_FILE           equ    $0013    ;     Rename File                           
0014                  FC_COPY_FILE          equ    $0014    ;     Copy File                             
0015                  FC_SEEK_START         equ    $0015    ;     Seek Start                            
0016                  FC_SEEK_END           equ    $0016    ;     Seek End                              
0017                  FC_SET_SEEK           equ    $0017    ;     Set Seek Position (from FIO_IOWORD)   
0018                  FC_GET_SEEK           equ    $0018    ;     Get Seek Position (into FIO_IOWORD)   
0018                  FC_LAST               equ    $0018    ;   End FIO_COMMAND enumeration             
                                                            ; 
FE88                  FIO_HANDLE            equ    $FE88    ; (Byte) Current File Stream HANDLE (0=NONE)
FE89                  FIO_SEEKPOS           equ    $FE89    ; (DWord) File Seek Position
FE8D                  FIO_IODATA            equ    $FE8D    ; (Byte) Input / Output Data
                                                            ; 
FE8E                  FIO_PATH_LEN          equ    $FE8E    ; (Byte) Length of the Primary Filepath        (Read Only)
FE8F                  FIO_PATH_POS          equ    $FE8F    ; (Byte) Character Position Within the Primary Filepath
FE90                  FIO_PATH_DATA         equ    $FE90    ; (Byte) Data at the Character Position of the Primary Path
                                                            ; 
FE91                  FIO_ALT_PATH_LEN      equ    $FE91    ; (Byte) Length of the alternate Filepath        (Read Only)
FE92                  FIO_ALT_PATH_POS      equ    $FE92    ; (Byte) Character Position Within the Alternate Filepath
FE93                  FIO_ALT_PATH_DATA     equ    $FE93    ; (Byte) Data at the Character Position of the Alternate Path
                                                            ; 
FE94                  FIO_DIR_DATA          equ    $FE94    ; (Byte) A Series of Null-Terminated Filenames
                                                            ;   NOTE: Current read-position is reset to the beginning
                                                            ;     following a List Directory command. The read-position
                                                            ;     is automatically advanced on read from this register.
                                                            ;     Each filename is $0A-terminated. The list itself is
                                                            ;     null-terminated.
                                                            ; 
FE94                  FIO_END               equ    $FE94    ; End of FIO Device Register Space
FE95                  FIO_TOP               equ    $FE95    ; Top of FIO Device Register Space
                      ; _______________________________________________________________________
                      
FE95                  MATH_DEVICE           equ    $FE95    ; START: Math Co-Processor Device Hardware Registers
FE95                  MATH_ACA_POS          equ    $FE95    ; (Byte) Character Position Within the ACA Float String
FE96                  MATH_ACA_DATA         equ    $FE96    ; (Byte) ACA Float String Character Port
FE97                  MATH_ACA_RAW          equ    $FE97    ; (4-Bytes) ACA Raw Float Data
FE9B                  MATH_ACA_INT          equ    $FE9B    ; (4-Bytes) ACA Integer Data
                                                            ; 
FE9F                  MATH_ACB_POS          equ    $FE9F    ; (Byte) Character Position Within the ACB Float String
FEA0                  MATH_ACB_DATA         equ    $FEA0    ; (Byte) ACB Float String Character Port
FEA1                  MATH_ACB_RAW          equ    $FEA1    ; (4-Bytes) ACB Raw Float Data
FEA5                  MATH_ACB_INT          equ    $FEA5    ; (4-Bytes) ACB Integer Data
                                                            ; 
FEA9                  MATH_ACR_POS          equ    $FEA9    ; (Byte) Character Position Within the ACR Float String
FEAA                  MATH_ACR_DATA         equ    $FEAA    ; (Byte) ACR Float String Character Port
FEAB                  MATH_ACR_RAW          equ    $FEAB    ; (4-Bytes) ACR Raw Float Data
FEAF                  MATH_ACR_INT          equ    $FEAF    ; (4-Bytes) ACR Integer Data
                                                            ; 
FEB3                  MATH_OPERATION        equ    $FEB3    ; (Byte) ACA Float String Character Port   (On Write)
0000                  MOP_BEGIN             equ    $0000    ;   BEGIN Math Operation Enumeration:
0000                  MOP_RANDOM            equ    $0000    ;     ACA, ACB, and ACR are set to randomized values
0001                  MOP_RND_SEED          equ    $0001    ;     MATH_ACA_INT seeds the pseudo-random number generator
0002                  MOP_IS_EQUAL          equ    $0002    ;     (bool)ACR = (ACA == ACB)
0003                  MOP_IS_NOT_EQUAL      equ    $0003    ;     (bool)ACR = (ACA != ACB)
0004                  MOP_IS_LESS           equ    $0004    ;     (bool)ACR = std::isless(ACA, ACB)
0005                  MOP_IS_GREATER        equ    $0005    ;     (bool)ACR = std::isgreater(ACA, ACB)
0006                  MOP_IS_LTE            equ    $0006    ;     (bool)ACR = std::islessequal(ACA, ACB)
0007                  MOP_IS_GTE            equ    $0007    ;     (bool)ACR = std::islessgreater(ACA, ACB)
0008                  MOP_IS_FINITE         equ    $0008    ;     (bool)ACR = std::isfinite(ACA)
0009                  MOP_IS_INF            equ    $0009    ;     (bool)ACR = std::isinf(ACA)
000A                  MOP_IS_NAN            equ    $000A    ;     (bool)ACR = std::isnan(ACA)
000B                  MOP_IS_NORMAL         equ    $000B    ;     (bool)ACR = std::isnormal(ACA)
000C                  MOP_SIGNBIT           equ    $000C    ;     (bool)ACR = std::signbit(ACA)
000D                  MOP_SUBTRACT          equ    $000D    ;     ACR = ACA - ACB
000E                  MOP_ADD               equ    $000E    ;     ACR = ACA + ACB
000F                  MOP_MULTIPLY          equ    $000F    ;     ACR = ACA * ACB
0010                  MOP_DIVIDE            equ    $0010    ;     ACR = ACA / ACB
0011                  MOP_FMOD              equ    $0011    ;     ACR = std::fmod(ACA, ACB)
0012                  MOP_REMAINDER         equ    $0012    ;     ACR = std::remainder(ACA, ACB)
0013                  MOP_FMAX              equ    $0013    ;     ACR = std::fmax(ACA, ACB)
0014                  MOP_FMIN              equ    $0014    ;     ACR = std::fmin(ACA, ACB)
0015                  MOP_FDIM              equ    $0015    ;     ACR = std::fdim(ACA, ACB)
0016                  MOP_EXP               equ    $0016    ;     ACR = std::exp(ACA)
0017                  MOP_EXP2              equ    $0017    ;     ACR = std::exp2(ACA)
0018                  MOP_EXPM1             equ    $0018    ;     ACR = std::expm1(ACA)
0019                  MOP_LOG               equ    $0019    ;     ACR = std::log(ACA)
001A                  MOP_LOG10             equ    $001A    ;     ACR = std::log10(ACA)
001B                  MOP_LOG2              equ    $001B    ;     ACR = std::log2(ACA)
001C                  MOP_LOG1P             equ    $001C    ;     ACR = std::log1p(ACA)
001D                  MOP_SQRT              equ    $001D    ;     ACR = std::sqrt(ACA)
001E                  MOP_CBRT              equ    $001E    ;     ACR = std::cbrt(ACA)
001F                  MOP_HYPOT             equ    $001F    ;     ACR = std::hypot(ACA, ACB)
0020                  MOP_POW               equ    $0020    ;     ACR = std::pow(ACA, ACB)
0021                  MOP_SIN               equ    $0021    ;     ACR = std::sin(ACA)
0022                  MOP_COS               equ    $0022    ;     ACR = std::cos(ACA)
0023                  MOP_TAN               equ    $0023    ;     ACR = std::tan(ACA)
0024                  MOP_ASIN              equ    $0024    ;     ACR = std::asin(ACA)
0025                  MOP_ACOS              equ    $0025    ;     ACR = std::acos(ACA)
0026                  MOP_ATAN              equ    $0026    ;     ACR = std::atan(ACA)
0027                  MOP_ATAN2             equ    $0027    ;     ACR = std::atan2(ACA, ACB)
0028                  MOP_SINH              equ    $0028    ;     ACR = std::sinh(ACA)
0029                  MOP_COSH              equ    $0029    ;     ACR = std::cosh(ACA)
002A                  MOP_ASINH             equ    $002A    ;     ACR = std::asinh(ACA)
002B                  MOP_ACOSH             equ    $002B    ;     ACR = std::acosh(ACA)
002C                  MOP_ATANH             equ    $002C    ;     ACR = std::atanh(ACA)
002D                  MOP_ERF               equ    $002D    ;     ACR = std::erf(ACA)
002E                  MOP_ERFC              equ    $002E    ;     ACR = std::erfc(ACA)
002F                  MOP_LGAMMA            equ    $002F    ;     ACR = std::lgamma(ACA)
0030                  MOP_TGAMMA            equ    $0030    ;     ACR = std::tgamma(ACA)
0031                  MOP_CEIL              equ    $0031    ;     ACR = std::ceil(ACA)
0032                  MOP_FLOOR             equ    $0032    ;     ACR = std::floor(ACA)
0033                  MOP_TRUNC             equ    $0033    ;     ACR = std::trunc(ACA)
0034                  MOP_ROUND             equ    $0034    ;     ACR = std::round(ACA)
0035                  MOP_LROUND            equ    $0035    ;     ACR = std::lround(ACA)
0036                  MOP_NEARBYINT         equ    $0036    ;     ACR = std::nearbyint(ACA)
0037                  MOP_ILOGB             equ    $0037    ;     ACR = std::ilogb(ACA)
0038                  MOP_LOGB              equ    $0038    ;     ACR = std::logb(ACA)
0039                  MOP_NEXTAFTER         equ    $0039    ;     ACR = std::nextafter(ACA, ACB)
003A                  MOP_COPYSIGN          equ    $003A    ;     ACR = std::copysign(ACA, ACB)
003B                  MOP_LASTOP            equ    $003B    ;   END Math Operation Enumeration
FEB3                  MATH_END              equ    $FEB3    ; End of Math Co-Processor Register Space
FEB4                  MATH_TOP              equ    $FEB4    ; Top of Math Co-Processor Register Space
                      ; _______________________________________________________________________
                      
FEB4                  MMU_DEVICE            equ    $FEB4    ; START: Memory Management Unit Hardware Registers
FEB4                  MMU_PAGE_1_SELECT     equ    $FEB4    ; (Word) Page Select for 8K Memory Bank 1
FEB6                  MMU_PAGE_2_SELECT     equ    $FEB6    ; (Word) Page Select for 8K Memory Bank 2
FEB8                  MMU_BLOCKS_FREE       equ    $FEB8    ; (Word) Number of 32-Byte Blocks Available for Allocation (Read Only)
FEBA                  MMU_BLOCKS_ALLOCATED  equ    $FEBA    ; (Word) Number of 32-Byte Blocks Currently Allocated  (Read Only)
FEBC                  MMU_BLOCKS_FRAGGED    equ    $FEBC    ; (Word) Number of 32-Byte Blocks Currently Fragmented  (Read Only)
FEBE                  MMU_ARG_1             equ    $FEBE    ; (Word) Argument 1 for MMU Command
FEBE                  MMU_ARG_1_MSB         equ    $FEBE    ; (Byte) Argument 1 Most Significant Byte for MMU Command
FEBF                  MMU_ARG_1_LSB         equ    $FEBF    ; (Byte) Argument 1 Least Significant Byte for MMU Command
FEC0                  MMU_ARG_2             equ    $FEC0    ; (Word) Argument 2 for MMU Command
FEC0                  MMU_ARG_2_MSB         equ    $FEC0    ; (Byte) Argument 2 Most Significant Byte for MMU Command
FEC1                  MMU_ARG_2_LSB         equ    $FEC1    ; (Byte) Argument 2 Least Significant Byte for MMU Command
                                                            ; 
FEC2                  MMU_COMMAND           equ    $FEC2    ; (Byte) Memory Management Unit Command:
0000                  MMU_CMD_NOP           equ    $0000    ;    $00 = No Operation / Error
0001                  MMU_CMD_PG_ALLOC      equ    $0001    ;    $01 = Page Allocate (8K Bytes)
0002                  MMU_CMD_PG_FREE       equ    $0002    ;    $02 = Page Deallocate (8K Bytes)
0003                  MMU_CMD_ALLOC         equ    $0003    ;    $03 = Allocate Chain (< 8K Bytes)
0004                  MMU_CMD_LOAD_ROOT     equ    $0004    ;    $04 = Load Root Node
0005                  MMU_CMD_LOAD_NEXT     equ    $0005    ;    $05 = Load Next Node
0006                  MMU_CMD_LOAD_PREV     equ    $0006    ;    $06 = Load Prev Node
0007                  MMU_CMD_LOAD_LAST     equ    $0007    ;    $07 = Load Last Node
0008                  MMU_CMD_DEL_NODE      equ    $0008    ;    $08 = Remove Current Node (and Adjust Links)
0009                  MMU_CMD_INS_BEFORE    equ    $0009    ;    $09 = Insert Node Before (and activate)
000A                  MMU_CMD_INS_AFTER     equ    $000A    ;    $0A = Insert Node After (and activate)
000B                  MMU_CMD_PUSH_BACK     equ    $000B    ;    $0B = Push Back (and activate)
000C                  MMU_CMD_PUSH_FRONT    equ    $000C    ;    $0C = Push Front (and activate)
000D                  MMU_CMD_POP_BACK      equ    $000D    ;    $0D = Pop Back (and activate)
000E                  MMU_CMD_POP_FRONT     equ    $000E    ;    $0E = Pop Front (and activate)
000F                  MMU_CMD_LOCK_NODE     equ    $000F    ;    $0F = Lock Node
0010                  MMU_CMD_UNLOCK_NODE   equ    $0010    ;    $10 = Unlock Node
0011                  MMU_CMD_FREE          equ    $0011    ;    $11 = Deallocate Chain (< 8K Bytes)
0012                  MMU_CMD_DEFRAG        equ    $0012    ;    $12 = Defragment / Collect Garbage
0013                  MMU_CMD_RESET         equ    $0013    ;    $13 = Reset Memory Management Unit
0014                  MMU_CMD_SIZE          equ    $0014    ;    $14 = Total Number of MMU Commands
                                                            ; 
FEC3                  MMU_ERROR             equ    $FEC3    ; (Byte) Memory Management Unit Error Code:     (Read Only)
0000                  MMU_ERR_NONE          equ    $0000    ;    $00 = No Error
0001                  MMU_ERR_ALLOC         equ    $0001    ;    $01 = Failed to Allocate Memory
0002                  MMU_ERR_FREE          equ    $0002    ;    $02 = Failed to Deallocate Memory
0003                  MMU_ERR_PG_FREE       equ    $0003    ;    $03 = Error Deallocating Page
0004                  MMU_ERR_INVALID       equ    $0004    ;    $04 = Invalid Command
0005                  MMU_ERR_HANDLE        equ    $0005    ;    $05 = Invalid Handle
0006                  MMU_ERR_NODE          equ    $0006    ;    $06 = Invalid Node
0007                  MMU_ERR_RAW_INDEX     equ    $0007    ;    $07 = Invalid Raw Index
0008                  MMU_ERR_SIZE          equ    $0008    ;    $08 = Total Number of MMU Errors
                                                            ; 
FEC4                  MMU_META_HANDLE       equ    $FEC4    ; (Word) Handle for the current allocation chain
                                                            ; 
FEC6                  MMU_META_STATUS       equ    $FEC6    ; (Byte) Status Flags:
0001                  MMU_STFLG_ALLOC       equ    $0001    ;    0000'0001: Is Allocated: 0 = Free, 1 = Allocated
0002                  MMU_STFLG_PAGED       equ    $0002    ;    0000'0010: Paged Memory: 0 = No,   1 = Yes
0004                  MMU_STFLG_READONLY    equ    $0004    ;    0000'0100: Memory Type:  0 = RAM,  1 = ROM
0008                  MMU_STFLG_FRAGD       equ    $0008    ;    0000'1000: Fragmented:   0 = No,   1 = Yes
0010                  MMU_STFLG_LOCKED      equ    $0010    ;    0001'0000: Locked:       0 = No,   1 = Yes
0020                  MMU_STFLG_RES_1       equ    $0020    ;    0010'0000:   (reserved)
0040                  MMU_STFLG_RES_2       equ    $0040    ;    0100'0000:   (reserved)
0080                  MMU_STFLG_ERROR       equ    $0080    ;    1000'0000: Error:        0 = No,   1 = Yes
                                                            ; 
FEC7                  MMU_META_DATA         equ    $FEC7    ; (32-Bytes) Data Window for the Current Allocation
FEE7                  MMU_META_ROOT         equ    $FEE7    ; (Word) Root node of the current allocation       (Read Only)
FEE9                  MMU_META_PREV         equ    $FEE9    ; (Word) Previous node of the current allocation   (Read Only)
FEEB                  MMU_META_NEXT         equ    $FEEB    ; (Word) Next node of the current allocation       (Read Only)
FEED                  MMU_RAW_INDEX         equ    $FEED    ; (Word) Raw Index of the current memory node  (Node Window)
                                                            ; 
FEEE                  MMU_END               equ    $FEEE    ; End of Banked Memory Register Space
FEEF                  MMU_TOP               equ    $FEEF    ; Top of Banked Memory Register Space
                      ; _______________________________________________________________________
                      
FEEF                  HDW_RESERVED_DEVICE   equ    $FEEF    ; START: Reserved Register Space
FFF0                  HDW_REG_END           equ    $FFF0    ; 257 bytes reserved for future use.
                      ; _______________________________________________________________________
                      
FFF0                  ROM_VECTS_DEVICE      equ    $FFF0    ; START: Hardware Interrupt Vectors
FFF0                  HARD_EXEC             equ    $FFF0    ; EXEC Hardware Interrupt Vector
FFF2                  HARD_SWI3             equ    $FFF2    ; SWI3 Hardware Interrupt Vector
FFF4                  HARD_SWI2             equ    $FFF4    ; SWI2 Hardware Interrupt Vector
FFF6                  HARD_FIRQ             equ    $FFF6    ; FIRQ Hardware Interrupt Vector
FFF8                  HARD_IRQ              equ    $FFF8    ; IRQ Hardware Interrupt Vector
FFFA                  HARD_SWI              equ    $FFFA    ; SWI / SYS Hardware Interrupt Vector
FFFC                  HARD_NMI              equ    $FFFC    ; NMI Hardware Interrupt Vector
FFFE                  HARD_RESET            equ    $FFFE    ; RESET Hardware Interrupt Vector
                      
                      
                      ; END of memory_map.asm definitions
                      
                      
                      
                      ; sys macro expands to SWI2 with a following command byte
                      sys                 macro
                                          swi2
                                          fcb \1
                                          endm
                      
                      
                      ; *****************************************************************************
                      ; * SYSTEM SOFTWARE VECTORS                                                   *
                      ; *****************************************************************************
0000                  VEC_EXEC            equ     $0000       ; User defined EXEC vector
0002                  VEC_SWI3            equ     $0002       ; SWI3 Software Interrupt Vector
0004                  VEC_SWI2            equ     $0004       ; SWI2 Software Interrupt Vector
0006                  VEC_FIRQ            equ     $0006       ; FIRQ Software Interrupt Vector
0008                  VEC_IRQ             equ     $0008       ; IRQ Software Interrupt Vector
000A                  VEC_SWI             equ     $000A       ; SWI / SYS Software Interrupt Vector
000C                  VEC_NMI             equ     $000C       ; NMI Software Interrupt Vector
000E                  VEC_RESET           equ     $000E       ; RESET Software Interrupt Vector
                      
                      ; *****************************************************************************
                      ; * KERNAL ROUTINE SOFTWARE VECTORS                                           *
                      ; *****************************************************************************
0010                  VEC_CLS             equ     $0010       ; CLS function Software Vector
0012                  VEC_CHROUT          equ     $0012       ; Character Out Software Vector
0014                  VEC_NEWLINE         equ     $0014       ; Kernel Newline Software Vector
0016                  VEC_LINEOUT         equ     $0016       ; String to Console Software Vector
0018                  VEC_CSRPOS          equ     $0018       ; Cursor Position Software Vector
001A                  VEC_SCROLL          equ     $001A       ; Scroll Text Screen Software Vector
001C                  VEC_LINEEDIT        equ     $001C       ; Console Line Editor Software Vector
001E                  VEC_GETKEY          equ     $001E       ; Wait for Key Press Software Vector
0020                  VEC_GETHEX          equ     $0020       ; Wait for Hex Character Software Vector
0022                  VEC_GETNUM          equ     $0022       ; Wait for Numeric Character Vector
0024                  VEC_CMPSTR          equ     $0024       ; Compare two strings of arbitrary lengths Vector
0026                  VEC_CMD_PROC        equ     $0026       ; Parse the command entered by the user Vector
0028                  VEC_TBLSEARCH       equ     $0028       ; Table Search and Return index Vector
002A                  VEC_CPY_DWORD       equ     $002A       ; Copy 32-bits from addr X addr Y Vector
002C                  VEC_D_TO_RAWA       equ     $002C       ; Write the D register to RAWA  Vector
002E                  VEC_D_TO_RAWB       equ     $002E       ; Write the D register to RAWB Vector
0030                  VEC_D_TO_RAWR       equ     $0030       ; Write the D register to RAWR Vector
0032                  VEC_D_TO_INTA       equ     $0032       ; Write the D register to INTA Vector
0034                  VEC_D_TO_INTB       equ     $0034       ; Write the D register to INTB Vector
0036                  VEC_D_TO_INTR       equ     $0036       ; Write the D register to INTR Vector
0038                  VEC_RAWA_TO_D       equ     $0038       ; Read the RAWA float into D Vector
003A                  VEC_RAWB_TO_D       equ     $003A       ; Read the RAWB float into D Vector
003C                  VEC_RAWR_TO_D       equ     $003C       ; Read the RAWD float into D Vector
003E                  VEC_INTA_TO_D       equ     $003E       ; Read the INTA integer into D Vector
0040                  VEC_INTB_TO_D       equ     $0040       ; Read the INTB integer into D Vector
0042                  VEC_INTR_TO_D       equ     $0042       ; Read the INTR integer into D Vector
0044                  VEC_8BIT_MATH       equ     $0044       ; 8-bit integer math Vector
0046                  VEC_DSP_ACA         equ     $0046       ; Send to console the float in ACA Vector
0048                  VEC_DSP_ACB         equ     $0048       ; Send to console the float in ACB Vector
004A                  VEC_DSP_ACR         equ     $004A       ; Send to console the float in ACA Vector
004C                  VEC_DSP_INTA        equ     $004C       ; Send to console the integer in ACA Vector
004E                  VEC_DSP_INTB        equ     $004E       ; Send to console the integer in ACB Vector
0050                  VEC_DSP_INTR        equ     $0050       ; Send to console the integer in ACR Vector
0052                  VEC_WRITE_ACA       equ     $0052       ; Write RAW float X points to into ACA Vector
0054                  VEC_WRITE_ACB       equ     $0054       ; Write RAW float X points to into ACB Vector
0056                  VEC_WRITE_ACR       equ     $0056       ; Write RAW float X points to into ACR Vector
0058                  VEC_ARG_TO_A        equ     $0058       ; Convert numeric string to binary in A Vector
                      
                      
                      ; *****************************************************************************
                      ; * RESERVED ZERO PAGE KERNAL VARIABLES                                       *
                      ; *****************************************************************************
005A                  _CURSOR_COL         equ     $005A       ; (Byte) current cursor horizontal position
005B                  _CURSOR_ROW         equ     $005B       ; (Byte) current cursor vertical position
005C                  _ATTRIB             equ     $005C       ; (Byte) current character display attribute
005D                  _ANCHOR_COL         equ     $005D       ; (Byte) line edit anchor column
005E                  _ANCHOR_ROW         equ     $005E       ; (Byte) line edit anchor row
005F                  _LOCAL_0            equ     $005F       ; (Byte) used locally for some kernel calls
0060                  _LOCAL_1            equ     $0060       ; (Byte) used locally for some kernel calls
0061                  _LOCAL_2            equ     $0061       ; (Byte) used locally for some kernel calls
0062                  _LOCAL_3            equ     $0062       ; (Byte) used locally for some kernel calls
                      
0063                  ZERO_PAGE_USER      equ     _LOCAL_3+1  ; start of user appropriate zero-page memory
                      
                      
                      ; *******************************************************************************
                      ; * SYS CALL CONSTANTS                                                          *
                      ; *     usage:                                                                  *
                      ; *             sys     CALL_CLS        ; clear the screen                      *
                      ; *             ...                                                             *
                      ; *                                                                             *
                      ; *             lda     #'Z'            ; Load the text glyph 'Z' into A        *
                      ; *             sys     CALL_CHROUT     ; Display the 'Z' on the text screen    *
                      ; *             ...                                                             *
                      ; *                                                                             *
                      ; *                                                                             *
                      ; *             sys     CALL_LINEOUT    ; Display Null-terminated string        *
                      ; *                                     ; pointed to by X at the current        *
                      ; *                                     ; cursor location:                      *
                      ; *                                             _CURSOR_COL x _CURSOR_ROW       *
                      ; *             ...                                                             *
                      ; *******************************************************************************
0000                  CALL_GARBAGE        equ     $00     ; $00 random garbage
0001                  CALL_CLS            equ     $01         ; $01 CLS
0002                  CALL_CHROUT         equ     $02     ; $02 CHROUT
0003                  CALL_NEWLINE        equ     $03         ; $03 NEWLINE
0004                  CALL_TAB            equ     $04         ; $04 TAB
0005                  CALL_LINEOUT        equ     $05         ; $05 LINEOUT
0006                  CALL_CSRPOS         equ     $06         ; $06 CSRPOS
0007                  CALL_SCROLL         equ     $07         ; $07 SCROLL
0008                  CALL_LINEEDIT       equ     $08     ; $08 LINEEDIT
0009                  CALL_GETKEY         equ     $09     ; $09 GETKEY
000A                  CALL_GETHEX         equ     $0A     ; $0A GETHEX
000B                  CALL_GETNUM         equ     $0B     ; $0B GETNUM
000C                  CALL_CMPSTR         equ     $0C     ; $0C CMPSTR
000D                  CALL_CMD_PROC       equ     $0D     ; $0D CMD_PROC
000E                  CALL_TBLSEARCH      equ     $0E     ; $0E TBLSEARCH
000F                  CALL_CPY_DWORD      equ     $0F     ; $0F CPY_DWORD
0010                  CALL_D_TO_RAWA      equ     $10     ; $10 D_TO_RAWA
0011                  CALL_D_TO_RAWB      equ     $11     ; $11 D_TO_RAWB
0012                  CALL_D_TO_RAWR      equ     $12     ; $12 D_TO_RAWR
0013                  CALL_D_TO_INTA      equ     $13     ; $13 D_TO_INTA
0014                  CALL_D_TO_INTB      equ     $14     ; $14 D_TO_INTB
0015                  CALL_D_TO_INTR      equ     $15     ; $15 D_TO_INTR
0016                  CALL_RAWA_TO_D      equ     $16     ; $16 RAWA_TO_D
0017                  CALL_RAWB_TO_D      equ     $17     ; $17 RAWB_TO_D
0018                  CALL_RAWR_TO_D      equ     $18     ; $18 RAWR_TO_D
0019                  CALL_INTA_TO_D      equ     $19     ; $19 INTA_TO_D
001A                  CALL_INTB_TO_D      equ     $1A     ; $1A INTB_TO_D
001B                  CALL_INTR_TO_D      equ     $1B     ; $1B INTR_TO_D
001C                  CALL_8BIT_MATH      equ     $1C     ; $1C 8BIT_MATH
001D                  CALL_DSP_ACA        equ     $1D     ; $1D DSP_ACA
001E                  CALL_DSP_ACB        equ     $1E     ; $1E DSP_ACB
001F                  CALL_DSP_ACR        equ     $1F     ; $1F DSP_ACR
0020                  CALL_DSP_INTA       equ     $20     ; $20 DSP_INTA
0021                  CALL_DSP_INTB       equ     $21     ; $21 DSP_INTB
0022                  CALL_DSP_INTR       equ     $22     ; $22 DSP_INTR
0023                  CALL_WRITE_ACA      equ     $23     ; $23 WRITE_ACA
0024                  CALL_WRITE_ACB      equ     $24     ; $24 WRITE_ACB
0025                  CALL_WRITE_ACR      equ     $25     ; $25 WRITE_ACR
0026                  CALL_ARG_TO_A       equ     $26     ; $26 ARG_TO_A
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
0000                                  org     $0000           ; point at the EXEC vector
0000  2400                            fdb     start           ; set the starting addresss of the program
                      
2400                                  org $2400               ; point to the start of user memory
                      
2400                  start                   
2400  CC0100                          ldd     #$0100
2403  8E0400          lp2             ldx     #VIDEO_START            
2406  C30001                          addd    #1
2409  ED81            lp1             std     ,x++
240B  C30001                          addd    #1
                      
                              ; test for a key press
240E  7DFE5C                          tst     CHAR_Q_LEN
2411  2607                            bne     cleanup
                      
2413  BCFE0D                          cmpx    GPU_VIDEO_MAX
2416  2DF1                            blt     lp1
2418  20E9                            bra     lp2
                              
241A                  cleanup ; clean up the queue
241A  B6FE5D                          lda     CHAR_SCAN
241D  2603                            bne     done
241F  B6FE5E                          lda     CHAR_POP
2422                  done    ; clean up and return
                      
2422                                  sys     CALL_CLS
2422  103F                                swi2
2424  01                                  fcb \1
2425  39                              rts
                      
                      
                      
                      
