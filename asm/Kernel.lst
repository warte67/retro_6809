                      ;*** kernel.asm ************************
                       *      _  __                    _                           
                       *     | |/ /___ _ __ _ __   ___| |       __ _ ___ _ __ ___  
                       *     | ' // _ \ '__| '_ \ / _ \ |      / _` / __| '_ ` _ \ 
                       *     | . \  __/ |  | | | |  __/ |  _  | (_| \__ \ | | | | |
                       *     |_|\_\___|_|  |_| |_|\___|_| (_)  \__,_|___/_| |_| |_|
                      ;*                
                      ;* Released under the GPL v3.0 License.
                      ;* Original Author: Jay Faries (warte67)                                           
                      ;*****************************
                      
                      
                      
                      
                      
                      
                                      ; INCLUDE "Memory_Map.asm"
0000                                  INCLUDE "Kernel_Header.asm"
                      ; ***** kernel_header.asm ************************************************************************
                      ; *      _  __                    _     _   _                _                                 
                      ; *     | |/ /___ _ __ _ __   ___| |   | | | | ___  __ _  __| | ___ _ __    __ _ ___ _ __ ___  
                      ; *     | ' // _ \ '__| '_ \ / _ \ |   | |_| |/ _ \/ _` |/ _` |/ _ \ '__|  / _` / __| '_ ` _ \ 
                      ; *     | . \  __/ |  | | | |  __/ |   |  _  |  __/ (_| | (_| |  __/ |_   | (_| \__ \ | | | | |
                      ; *     |_|\_\___|_|  |_| |_|\___|_|___|_| |_|\___|\__,_|\__,_|\___|_(_)   \__,_|___/_| |_| |_|
                      ; *                               |_____|                          
                      ; *                                                                                             
                      ; ************************************************************************************************           
                      
0000                                  INCLUDE "Memory_Map.asm"
                      ;*** Memory_Map.asm *************************************************
                      ;*    __  __                                     __  __                                 
                      ;*   |  \/  |                                   |  \/  |                                
                      ;*   | \  / | ___ _ __ ___   ___  _ __ _   _    | \  / | __ _ _ __   __ _ ___ _ __ ___  
                      ;*   | |\/| |/ _ \ '_ ` _ \ / _ \| '__| | | |   | |\/| |/ _` | '_ \ / _` / __| '_ ` _ \ 
                      ;*   | |  | |  __/ | | | | | (_) | |  | |_| |   | |  | | (_| | |_) | (_| \__ \ | | | | |
                      ;*   |_|  |_|\___|_| |_| |_|\___/|_|   \__, |   |_|  |_|\__,_| .__(_)__,_|___/_| |_| |_|
                      ;*                                      __/ |_____           | |                        
                      ;*                                     |___/______|          |_|                        
                      ;*
                      ;* 6809 Assembly Memory Map Definition File
                      ;*
                      ;* Released under the GPL v3.0 License.
                      ;* Original Author: Jay Faries (warte67)
                      ;*
                      ;************************************
                      
                      
                      
                      ;   **********************************************
                      ;   * Allocated 64k Memory Mapped System Symbols *
                      ;   **********************************************
                      ;
                      
0000                  SOFT_VECTORS_DEVICE   equ    $0000    ; START: Software Interrupt Vectors
0000                  SOFT_EXEC             equ    $0000    ; Exec Software Interrupt Vector
0002                  SOFT_SWI3             equ    $0002    ; SWI3 Software Interrupt Vector
0004                  SOFT_SWI2             equ    $0004    ; SWI2 Software Interrupt Vector
0006                  SOFT_FIRQ             equ    $0006    ; FIRQ Software Interrupt Vector
0008                  SOFT_IRQ              equ    $0008    ; IRQ Software Interrupt Vector
000A                  SOFT_SWI              equ    $000A    ; SWI / SYS Software Interrupt Vector
000C                  SOFT_NMI              equ    $000C    ; NMI Software Interrupt Vector
000E                  SOFT_RESET            equ    $000E    ; RESET Software Interrupt Vector
                      ; _______________________________________________________________________
                      
0010                  SYSTEM_MEMORY_DEVICE  equ    $0010    ; START: System Memory
0010                  ZERO_PAGE             equ    $0010    ; Zero Page System and User Variables
00FF                  ZERO_PAGE_END         equ    $00FF    ; Zero Page System and User Variables
0100                  FIO_LN_EDT_BUFFER     equ    $0100    ; START: Line Edit Character Buffer
01FF                  FIO_LN_EDT_END        equ    $01FF    ; END: Line Edit Character Buffer
0200                  SYSTEM_STACK          equ    $0200    ; Bottom of System Stack Spcace
03FF                  SSTACK_END            equ    $03FF    ; END: System Stack Space
0400                  SSTACK_TOP            equ    $0400    ; TOP: System Stack Space
                      ; _______________________________________________________________________
                      
0400                  VIDEO_BUFFER_DEVICE   equ    $0400    ; START: Video Buffer (8K)
0400                  VIDEO_START           equ    $0400    ; Start of standard video buffer
23FF                  VIDEO_END             equ    $23FF    ; End of standard video buffer
2400                  VIDEO_TOP             equ    $2400    ; Top of standard video buffer
                      ; _______________________________________________________________________
                      
2400                  USER_MEMORY_DEVICE    equ    $2400    ; START: User Memory (34K)
2400                  USER_RAM              equ    $2400    ; User Accessable RAM
AFFF                  USER_RAM_END          equ    $AFFF    ; End User Accessable RAM
B000                  USER_RAM_TOP          equ    $B000    ; Top User Accessable RAM
                      ; _______________________________________________________________________
                      
B000                  BANKED_MEMORY_REGION  equ    $B000    ; START: Banked Memory Region (16K)
B000                  BANKMEM_ONE           equ    $B000    ; Banked Memory Page One (8K)
D000                  BANKMEM_TWO           equ    $D000    ; Banked Memory Page Two (8K)
EFFF                  BANKMEM_END           equ    $EFFF    ; End of Banked Memory Region
F000                  BANKMEM_TOP           equ    $F000    ; TOP of Banked Memory Region
                      ; _______________________________________________________________________
                      
F000                  KERNEL_ROM_DEVICE     equ    $F000    ; START: Kernel Rom (3.5K)
F000                  KERNEL_START          equ    $F000    ; Start of Kernel Rom Space
FDFF                  KERNEL_END            equ    $FDFF    ; End of Kernel Rom Space
FE00                  KERNEL_TOP            equ    $FE00    ; Top of Kernel Rom Space
                      ; _______________________________________________________________________
                      
FE00                  SYS_DEVICE            equ    $FE00    ; START: System and Debug Hardware Registers:
FE00                  SYS_BEGIN             equ    $FE00    ; Start of System Registers
FE00                  SYS_STATE             equ    $FE00    ; (Byte) System State Register
                                                            ; SYS_STATE: ABCD.SSSS                          
                                                            ; - bit  7   = Error: Standard Buffer Overflow  
                                                            ; - bit  6   = Error: Extended Buffer Overflow  
                                                            ; - bit  5   = Error: Reserved                  
                                                            ; - bit  4   = Error: Reserved                  
                                                            ; - bits 0-3 = CPU Speed (0-15):                
                                                            ;    0 ($0)  = CPU Clock   10 kHz 
                                                            ;    1 ($1)  = CPU Clock   25 kHz 
                                                            ;    2 ($2)  = CPU Clock   50 kHz 
                                                            ;    3 ($3)  = CPU Clock   75 kHz 
                                                            ;    4 ($4)  = CPU Clock  100 kHz 
                                                            ;    5 ($5)  = CPU Clock  150 kHz 
                                                            ;    6 ($6)  = CPU Clock  225 kHz 
                                                            ;    7 ($7)  = CPU Clock  350 kHz 
                                                            ;    8 ($8)  = CPU Clock  500 kHz 
                                                            ;    9 ($9)  = CPU Clock  750 kHz 
                                                            ;   10 ($A)  = CPU Clock  900 kHz 
                                                            ;   11 ($B)  = CPU Clock 1000 khz 
                                                            ;   12 ($C)  = CPU Clock 2000 khz 
                                                            ;   13 ($D)  = CPU Clock 3000 khz 
                                                            ;   14 ($E)  = CPU Clock 4000 khz 
                                                            ;   15 ($F)  = CPU Clock ~10.0 mhz. (unmetered) 
                                                            ; 
FE01                  SYS_SPEED             equ    $FE01    ; (Word) Average CPU Clock Speed (Read Only)
FE03                  SYS_CLOCK_DIV         equ    $FE03    ; (Byte) 60 hz Clock Divider Register (Read Only)
                                                            ; - bit 7: 0.546875 hz
                                                            ; - bit 6: 1.09375 hz
                                                            ; - bit 5: 2.1875 hz
                                                            ; - bit 4: 4.375 hz
                                                            ; - bit 3: 8.75 hz
                                                            ; - bit 2: 17.5 hz
                                                            ; - bit 1: 35.0 hz
                                                            ; - bit 0: 70.0 hz
                                                            ; 
FE04                  SYS_UPDATE_COUNT      equ    $FE04    ; (DWord) Update Count (Read Only)
FE08                  SYS_DBG_BRK_ADDR      equ    $FE08    ; (Word) Address of current debug breakpoint
FE0A                  SYS_DBG_FLAGS         equ    $FE0A    ; (Byte) Debug Specific Hardware Flags:
                                                            ; - bit 7: Debug Enable
                                                            ; - bit 6: Single Step Enable
                                                            ; - bit 5: Clear All Breakpoints
                                                            ; - bit 4: Update Breakpoint at DEBUG_BRK_ADDR
                                                            ; - bit 3: FIRQ  (on low {0} to high {1} edge)
                                                            ; - bit 2: IRQ   (on low {0} to high {1} edge)
                                                            ; - bit 1: NMI   (on low {0} to high {1} edge)
                                                            ; - bit 0: RESET (on low {0} to high {1} edge)
                                                            ; 
FE0A                  SYS_END               equ    $FE0A    ; End of System Registers
FE0B                  SYS_TOP               equ    $FE0B    ; Top of System Registers
                      ; _______________________________________________________________________
                      
FE0B                  GPU_DEVICE            equ    $FE0B    ; START: GPU Device Hardware Registers
FE0B                  GPU_OPTIONS           equ    $FE0B    ; (Byte) Bitflag Enables
                                                            ; - bit 7    = Extended Bitmap:
                                                            ;               0: Tilemap Display
                                                            ;               1: Bitmap Display
                                                            ; - bits 5-6 = Extended Color Mode:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bits 4   = Extended Display Enable
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bits 3   = Emulation Screen Mode
                                                            ;               (temporary)
                                                            ;               0: Windowed
                                                            ;               1: Fullscreen
                                                            ; - bits 2   = VSync Enable
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bit  1   = Presentation
                                                            ;               0: Overscan / Stretch
                                                            ;               1: Letterbox
                                                            ; - bit  0   = Standard Display Enable
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; 
FE0C                  GPU_MODE              equ    $FE0C    ; (Byte) Standard Display Mode
                                                            ; - bit 7    = Standard Bitmap:
                                                            ;               0: Text Display
                                                            ;               1: Bitmap Display
                                                            ; - bits 5-6 = Standard Color Mode:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bits 0-4 = Display Mode (0-31)
                                                            ; 
FE0D                  GPU_VIDEO_MAX         equ    $FE0D    ; (Word) Video Buffer Maximum (Read Only)
                                                            ;  Note: This will change to reflect
                                                            ;        the size of the last cpu
                                                            ;        accessible memory location
                                                            ;        of the currently active
                                                            ;        standard video mode.
                                                            ; 
FE0F                  GPU_HRES              equ    $FE0F    ; (Word) Horizontal Pixel Resolution (Read Only)
                                                            ;   Note: This will reflect the number of
                                                            ;        pixel columns for bitmap modes.
                                                            ; 
FE11                  GPU_VRES              equ    $FE11    ; (Word) Vertical Pixel Resolution (Read Only)
                                                            ;   Note: This will reflect the number of
                                                            ;        pixel rows for bitmap modes.
                                                            ; 
FE13                  GPU_TCOLS             equ    $FE13    ; (Byte) Text Horizontal Columns (Read Only)
                                                            ;   Note: This will reflect the number of
                                                            ;        glyph columns for text modes.
                                                            ; 
FE14                  GPU_TROWS             equ    $FE14    ; (Byte) Text Vertical Rows (Read Only)
                                                            ;   Note: This will reflect the number of
                                                            ;        glyph rows for text modes.
                                                            ; 
FE15                  GPU_PAL_INDEX         equ    $FE15    ; (Byte) Color Palette Index
                                                            ;   Note: Use this register to set the
                                                            ;        index into the Color Palette.
                                                            ;        Set this value prior referencing
                                                            ;        the color data (GPU_PAL_COLOR).
                                                            ; 
FE16                  GPU_PAL_COLOR         equ    $FE16    ; (Word) Color Palette Data (A4R4G4B4 format)
                                                            ;   Note: This is the color data for an
                                                            ;        individual palette entry. Write to 
                                                            ;        DSP_PAL_IDX with the index within the
                                                            ;        color palette prior to reading or
                                                            ;        writing the color data in the
                                                            ;        GFX_PAL_CLR register.
                                                            ; 
FE18                  GPU_GLYPH_IDX         equ    $FE18    ; (Byte) Text Glyph Index
                                                            ;   Note: Use this register to set the
                                                            ;        index of a specific text glyph.
                                                            ;        Set this value prior to updating
                                                            ;        the glyph data (GPU_GLYPH_DATA).
                                                            ; 
FE19                  GPU_GLYPH_DATA        equ    $FE19    ; (8-Bytes) 8 rows of binary encoded glyph pixel data
                                                            ;   Note: This is the pixel data for a
                                                            ;        specific text glyph. Each 8x8
                                                            ;        text glyph is composed of 8 bytes.
                                                            ;        The first byte in this array
                                                            ;        represents the top line of 8 pixels.
                                                            ;        Each array entry represents a row of 8 pixels.
                                                            ; 
FE20                  GPU_END               equ    $FE20    ; End of GPU Register Space
FE21                  GPU_TOP               equ    $FE21    ; Top of GPU Register Space
                      ; _______________________________________________________________________
                      
FE21                  CSR_DEVICE            equ    $FE21    ; START: Mouse Device Hardware Registers
FE21                  CSR_XPOS              equ    $FE21    ; (Word) Horizontal Mouse Cursor Coordinate
FE23                  CSR_YPOS              equ    $FE23    ; (Word) Vertical Mouse Cursor Coordinate
FE25                  CSR_XOFS              equ    $FE25    ; (Byte) Horizontal Mouse Cursor Offset
FE26                  CSR_YOFS              equ    $FE26    ; (Byte) Vertical Mouse Cursor Offset
FE27                  CSR_SCROLL            equ    $FE27    ; (char) MouseWheel Scroll: -1, 0, 1
FE28                  CSR_FLAGS             equ    $FE28    ; (Byte) Mouse Device State Flags
                                                            ;    bits 0-4: button states
                                                            ;    bits 5-6: number of clicks
                                                            ;    bits 7:   cursor enable
                                                            ; 
FE29                  CSR_BMP_INDX          equ    $FE29    ; (Byte) Mouse Cursor Bitmap Pixel Offset
FE2A                  CSR_BMP_DATA          equ    $FE2A    ; (Byte) Mouse Cursor Bitmap Pixel Color Data ($0-$F)
FE2B                  CSR_PAL_INDX          equ    $FE2B    ; (Byte) Mouse Cursor Color Palette Index (0-15)
FE2C                  CSR_PAL_DATA          equ    $FE2C    ; (Word) Mouse Cursor Color Palette Data A4R4G4B4
FE2D                  CSR_END               equ    $FE2D    ; End of Mouse Device Register Space
FE2E                  CSR_TOP               equ    $FE2E    ; Top of CSR Register Space
                      ; _______________________________________________________________________
                      
FE2E                  KEYBOARD_DEVICE       equ    $FE2E    ; START: Keyboard Device Hardware Registers
FE2E                  CHAR_Q_LEN            equ    $FE2E    ; (Byte) Number of Characters Waiting in Queue   (Read Only)
FE2F                  CHAR_SCAN             equ    $FE2F    ; (Byte) Read Next Character in Queue (Not Popped When Read)
FE30                  CHAR_POP              equ    $FE30    ; (Byte) Read Next Character in Queue     (Popped When Read)
FE31                  XKEY_BUFFER           equ    $FE31    ; (16 Bytes) 128 bits for XK_KEY data buffer     (Read Only)
FE41                  EDT_BFR_CSR           equ    $FE41    ; (Byte) Cursor Position Within Edit Buffer     (Read/Write)
FE42                  EDT_ENABLE            equ    $FE42    ; (Byte) Line Editor Enable Flag                (Read/Write)
FE43                  EDT_BFR_LEN           equ    $FE43    ; (Byte) Limit the Line Editor to This Length   (Read/Write)
FE43                  KEYBOARD_END          equ    $FE43    ; End of Keyboard Register Space
FE44                  KEYBOARD_TOP          equ    $FE44    ; Top of Keyboard Register Space
                      ; _______________________________________________________________________
                      
FE44                  JOYSTICK_DEVICE       equ    $FE44    ; START: Joystick/Gamepad Controller Device Hardware Registers
FE44                  JOYS_1_FLAGS          equ    $FE44    ; (Byte) Gamepad/Joystick #1 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE45                  JOYS_1_BTN            equ    $FE45    ; (Word) Gamepad Controller Button Bits:         (Read Only)
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = A
                                                            ;            0000'0000'0000'0010 = B
                                                            ;            0000'0000'0000'0100 = X
                                                            ;            0000'0000'0000'1000 = Y
                                                            ;            0000'0000'0001'0000 = L.Shoulder
                                                            ;            0000'0000'0010'0000 = R.Shoulder
                                                            ;            0000'0000'0100'0000 = Back
                                                            ;            0000'0000'1000'0000 = Start
                                                            ;            0000'0001'0000'0000 = Misc 1
                                                            ;            0000'0010'0000'0000 = Misc 2
                                                            ;            0000'0100'0000'0000 = Misc 3
                                                            ;            0000'1000'0000'0000 = Guide
                                                            ;            0001'0000'0000'0000 = DPad Up   
                                                            ;            0010'0000'0000'0000 = DPad Down 
                                                            ;            0100'0000'0000'0000 = DPad Left 
                                                            ;            1000'0000'0000'0000 = DPad Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE47                  JOYS_1_DBND           equ    $FE47    ; (Byte) PAD 1 analog deadband; default is 5   (read/write)
FE48                  JOYS_1_LTX            equ    $FE48    ; (char) PAD 1 LThumb-X position (-128 _ +127)   (realtime)
FE49                  JOYS_1_LTY            equ    $FE49    ; (char) PAD 1 LThumb-Y position (-128 _ +127)   (realtime)
FE4A                  JOYS_1_RTX            equ    $FE4A    ; (char) PAD 1 RThumb-X position (-128 _ +127)   (realtime)
FE4B                  JOYS_1_RTY            equ    $FE4B    ; (char) PAD 1 RThumb-Y position (-128 _ +127)   (realtime)
FE4C                  JOYS_1_Z1             equ    $FE4C    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
FE4D                  JOYS_1_Z2             equ    $FE4D    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
                                                            ; 
FE4E                  JOYS_2_FLAGS          equ    $FE4E    ; (Byte) Gamepad/Joystick #2 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE4F                  JOYS_2_BTN            equ    $FE4F    ; (Word) Button Bits: Room For up to 16 Buttons  (realtime)
                                                            ;        Joystick Button Bits:
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = Button 1 
                                                            ;            0000'0000'0000'0010 = Button 2 
                                                            ;            0000'0000'0000'0100 = Button 3 
                                                            ;            0000'0000'0000'1000 = Button 4 
                                                            ;            0000'0000'0001'0000 = Button 5 
                                                            ;            0000'0000'0010'0000 = Button 6 
                                                            ;            0000'0000'0100'0000 = Button 7 
                                                            ;            0000'0000'1000'0000 = Button 8 
                                                            ;            0000'0001'0000'0000 = Button 9 
                                                            ;            0000'0010'0000'0000 = Button 10
                                                            ;            0000'0100'0000'0000 = Button 11
                                                            ;            0000'1000'0000'0000 = Button 12
                                                            ;            0001'0000'0000'0000 = Hat Up   
                                                            ;            0010'0000'0000'0000 = Hat Down 
                                                            ;            0100'0000'0000'0000 = Hat Left 
                                                            ;            1000'0000'0000'0000 = Hat Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE51                  JOYS_2_DBND           equ    $FE51    ; (Byte) PAD 2 analog deadband; default is 5   (read/write)
FE52                  JOYS_2_LTX            equ    $FE52    ; (char) PAD 2 LThumb-X position (-128 _ +127)   (realtime)
FE53                  JOYS_2_LTY            equ    $FE53    ; (char) PAD 2 LThumb-Y position (-128 _ +127)   (realtime)
FE54                  JOYS_2_RTX            equ    $FE54    ; (char) PAD 2 RThumb-X position (-128 _ +127)   (realtime)
FE55                  JOYS_2_RTY            equ    $FE55    ; (char) PAD 2 RThumb-Y position (-128 _ +127)   (realtime)
FE56                  JOYS_2_Z1             equ    $FE56    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE57                  JOYS_2_Z2             equ    $FE57    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE57                  JOYS_END              equ    $FE57    ; End of Joystick/Gamepad Device Register Space
FE58                  JOYS_TOP              equ    $FE58    ; Top of Joystick/Gamepad Device Register Space
                      ; _______________________________________________________________________
                      
FE58                  FIO_DEVICE            equ    $FE58    ; START: File I/O Device Hardware Registers
FE58                  FIO_ERROR             equ    $FE58    ; (Byte) FILE_ERROR enumeration result (FE_<error>)
                                                            ; 
0000                  FE_BEGIN              equ    $0000    ;   Begin FILE_ERROR enumeration 
0000                  FE_NOERROR            equ    $0000    ;      no error, condition normal
0001                  FE_NOTFOUND           equ    $0001    ;      file or folder not found  
0002                  FE_NOTOPEN            equ    $0002    ;      file not open             
0003                  FE_EOF                equ    $0003    ;      end of file               
0004                  FE_OVERRUN            equ    $0004    ;      buffer overrun            
0005                  FE_WRONGTYPE          equ    $0005    ;      wrong file type           
0006                  FE_BAD_CMD            equ    $0006    ;      invalid command           
0007                  FE_BADSTREAM          equ    $0007    ;      invalid file stream       
0007                  FE_NOT_EMPTY          equ    $0007    ;      directory not empty       
0007                  FE_FILE_EXISTS        equ    $0007    ;      file already exists       
0007                  FE_INVALID_NAME       equ    $0007    ;      invalid file name         
0007                  FE_LAST               equ    $0007    ;   End of FILE_ERROR enumeration
                                                            ; 
FE59                  FIO_COMMAND           equ    $FE59    ; (Byte) Execute a File Command (FC_<cmd>)
                                                            ; 
0000                  FC_BEGIN              equ    $0000    ;   Begin FIO_COMMAND enumeration           
0000                  FC_RESET              equ    $0000    ;     Reset                                 
0001                  FC_SHUTDOWN           equ    $0001    ;     SYSTEM: Shutdown                      
0002                  FC_COMPDATE           equ    $0002    ;     SYSTEM: Load Compilation Date         
0003                  FC_FILEEXISTS         equ    $0003    ;     Does File Exist (return in FIO_IODATA)
0004                  FC_OPENREAD           equ    $0004    ;     Open Binary File For Reading          
0005                  FC_OPENWRITE          equ    $0005    ;     Open Binary File For Writing          
0006                  FC_OPENAPPEND         equ    $0006    ;     Open Binary File For Appending        
0007                  FC_CLOSEFILE          equ    $0007    ;     Close File                            
0008                  FC_READBYTE           equ    $0008    ;     Read Byte (into FIO_IOBYTE)           
0009                  FC_WRITEBYTE          equ    $0009    ;     Write Byte (from FIO_IOBYTE)          
000A                  FC_LOADHEX            equ    $000A    ;     Load Hex Format File                  
000B                  FC_GETLENGTH          equ    $000B    ;     Get File Length (into FIO_IOWORD)     
000C                  FC_LISTDIR            equ    $000C    ;     List Directory                        
000D                  FC_MAKEDIR            equ    $000D    ;     Make Directory                        
000E                  FC_CHANGEDIR          equ    $000E    ;     Change Directory                      
000F                  FC_GETPATH            equ    $000F    ;     Fetch Current Path                    
0010                  FC_REN_DIR            equ    $0010    ;     Rename Directory                      
0011                  FC_DEL_DIR            equ    $0011    ;     Delete Directory                      
0012                  FC_DEL_FILE           equ    $0012    ;     Delete File                           
0013                  FC_REN_FILE           equ    $0013    ;     Rename File                           
0014                  FC_COPY_FILE          equ    $0014    ;     Copy File                             
0015                  FC_SEEK_START         equ    $0015    ;     Seek Start                            
0016                  FC_SEEK_END           equ    $0016    ;     Seek End                              
0017                  FC_SET_SEEK           equ    $0017    ;     Set Seek Position (from FIO_IOWORD)   
0018                  FC_GET_SEEK           equ    $0018    ;     Get Seek Position (into FIO_IOWORD)   
0018                  FC_LAST               equ    $0018    ;   End FIO_COMMAND enumeration             
                                                            ; 
FE5A                  FIO_HANDLE            equ    $FE5A    ; (Byte) Current File Stream HANDLE (0=NONE)
FE5B                  FIO_SEEKPOS           equ    $FE5B    ; (DWord) File Seek Position
FE5F                  FIO_IODATA            equ    $FE5F    ; (Byte) Input / Output Data
                                                            ; 
FE60                  FIO_PATH_LEN          equ    $FE60    ; (Byte) Length of the Primary Filepath        (Read Only)
FE61                  FIO_PATH_POS          equ    $FE61    ; (Byte) Character Position Within the Primary Filepath
FE62                  FIO_PATH_DATA         equ    $FE62    ; (Byte) Data at the Character Position of the Primary Path
                                                            ; 
FE63                  FIO_ALT_PATH_LEN      equ    $FE63    ; (Byte) Length of the alternate Filepath        (Read Only)
FE64                  FIO_ALT_PATH_POS      equ    $FE64    ; (Byte) Character Position Within the Alternate Filepath
FE65                  FIO_ALT_PATH_DATA     equ    $FE65    ; (Byte) Data at the Character Position of the Alternate Path
                                                            ; 
FE66                  FIO_DIR_DATA          equ    $FE66    ; (Byte) A Series of Null-Terminated Filenames
                                                            ;   NOTE: Current read-position is reset to the beginning
                                                            ;     following a List Directory command. The read-position
                                                            ;     is automatically advanced on read from this register.
                                                            ;     Each filename is $0A-terminated. The list itself is
                                                            ;     null-terminated.
                                                            ; 
FE66                  FIO_END               equ    $FE66    ; End of FIO Device Register Space
FE67                  FIO_TOP               equ    $FE67    ; Top of FIO Device Register Space
                      ; _______________________________________________________________________
                      
FE67                  MATH_DEVICE           equ    $FE67    ; START: Math Co-Processor Device Hardware Registers
FE67                  MATH_ACA_POS          equ    $FE67    ; (Byte) Character Position Within the ACA Float String
FE68                  MATH_ACA_DATA         equ    $FE68    ; (Byte) ACA Float String Character Port
FE69                  MATH_ACA_RAW          equ    $FE69    ; (4-Bytes) ACA Raw Float Data
FE6D                  MATH_ACA_INT          equ    $FE6D    ; (4-Bytes) ACA Integer Data
                                                            ; 
FE71                  MATH_ACB_POS          equ    $FE71    ; (Byte) Character Position Within the ACB Float String
FE72                  MATH_ACB_DATA         equ    $FE72    ; (Byte) ACB Float String Character Port
FE73                  MATH_ACB_RAW          equ    $FE73    ; (4-Bytes) ACB Raw Float Data
FE77                  MATH_ACB_INT          equ    $FE77    ; (4-Bytes) ACB Integer Data
                                                            ; 
FE7B                  MATH_ACR_POS          equ    $FE7B    ; (Byte) Character Position Within the ACR Float String
FE7C                  MATH_ACR_DATA         equ    $FE7C    ; (Byte) ACR Float String Character Port
FE7D                  MATH_ACR_RAW          equ    $FE7D    ; (4-Bytes) ACR Raw Float Data
FE81                  MATH_ACR_INT          equ    $FE81    ; (4-Bytes) ACR Integer Data
                                                            ; 
FE85                  MATH_OPERATION        equ    $FE85    ; (Byte) ACA Float String Character Port   (On Write)
0000                  MOP_BEGIN             equ    $0000    ;   BEGIN Math Operation Enumeration:
0000                  MOP_RANDOM            equ    $0000    ;     ACA, ACB, and ACR are set to randomized values
0001                  MOP_RND_SEED          equ    $0001    ;     MATH_ACA_INT seeds the pseudo-random number generator
0002                  MOP_IS_EQUAL          equ    $0002    ;     (bool)ACR = (ACA == ACB)
0003                  MOP_IS_NOT_EQUAL      equ    $0003    ;     (bool)ACR = (ACA != ACB)
0004                  MOP_IS_LESS           equ    $0004    ;     (bool)ACR = std::isless(ACA, ACB)
0005                  MOP_IS_GREATER        equ    $0005    ;     (bool)ACR = std::isgreater(ACA, ACB)
0006                  MOP_IS_LTE            equ    $0006    ;     (bool)ACR = std::islessequal(ACA, ACB)
0007                  MOP_IS_GTE            equ    $0007    ;     (bool)ACR = std::islessgreater(ACA, ACB)
0008                  MOP_IS_FINITE         equ    $0008    ;     (bool)ACR = std::isfinite(ACA)
0009                  MOP_IS_INF            equ    $0009    ;     (bool)ACR = std::isinf(ACA)
000A                  MOP_IS_NAN            equ    $000A    ;     (bool)ACR = std::isnan(ACA)
000B                  MOP_IS_NORMAL         equ    $000B    ;     (bool)ACR = std::isnormal(ACA)
000C                  MOP_SIGNBIT           equ    $000C    ;     (bool)ACR = std::signbit(ACA)
000D                  MOP_SUBTRACT          equ    $000D    ;     ACR = ACA - ACB
000E                  MOP_ADD               equ    $000E    ;     ACR = ACA + ACB
000F                  MOP_MULTIPLY          equ    $000F    ;     ACR = ACA * ACB
0010                  MOP_DIVIDE            equ    $0010    ;     ACR = ACA / ACB
0011                  MOP_FMOD              equ    $0011    ;     ACR = std::fmod(ACA, ACB)
0012                  MOP_REMAINDER         equ    $0012    ;     ACR = std::remainder(ACA, ACB)
0013                  MOP_FMAX              equ    $0013    ;     ACR = std::fmax(ACA, ACB)
0014                  MOP_FMIN              equ    $0014    ;     ACR = std::fmin(ACA, ACB)
0015                  MOP_FDIM              equ    $0015    ;     ACR = std::fdim(ACA, ACB)
0016                  MOP_EXP               equ    $0016    ;     ACR = std::exp(ACA)
0017                  MOP_EXP2              equ    $0017    ;     ACR = std::exp2(ACA)
0018                  MOP_EXPM1             equ    $0018    ;     ACR = std::expm1(ACA)
0019                  MOP_LOG               equ    $0019    ;     ACR = std::log(ACA)
001A                  MOP_LOG10             equ    $001A    ;     ACR = std::log10(ACA)
001B                  MOP_LOG2              equ    $001B    ;     ACR = std::log2(ACA)
001C                  MOP_LOG1P             equ    $001C    ;     ACR = std::log1p(ACA)
001D                  MOP_SQRT              equ    $001D    ;     ACR = std::sqrt(ACA)
001E                  MOP_CBRT              equ    $001E    ;     ACR = std::cbrt(ACA)
001F                  MOP_HYPOT             equ    $001F    ;     ACR = std::hypot(ACA, ACB)
0020                  MOP_POW               equ    $0020    ;     ACR = std::pow(ACA, ACB)
0021                  MOP_SIN               equ    $0021    ;     ACR = std::sin(ACA)
0022                  MOP_COS               equ    $0022    ;     ACR = std::cos(ACA)
0023                  MOP_TAN               equ    $0023    ;     ACR = std::tan(ACA)
0024                  MOP_ASIN              equ    $0024    ;     ACR = std::asin(ACA)
0025                  MOP_ACOS              equ    $0025    ;     ACR = std::acos(ACA)
0026                  MOP_ATAN              equ    $0026    ;     ACR = std::atan(ACA)
0027                  MOP_ATAN2             equ    $0027    ;     ACR = std::atan2(ACA, ACB)
0028                  MOP_SINH              equ    $0028    ;     ACR = std::sinh(ACA)
0029                  MOP_COSH              equ    $0029    ;     ACR = std::acosh(ACA)
002A                  MOP_ATANH             equ    $002A    ;     ACR = std::atanh(ACA)
002B                  MOP_ERF               equ    $002B    ;     ACR = std::erf(ACA)
002C                  MOP_ERFC              equ    $002C    ;     ACR = std::erfc(ACA)
002D                  MOP_LGAMMA            equ    $002D    ;     ACR = std::lgamma(ACA)
002E                  MOP_TGAMMA            equ    $002E    ;     ACR = std::tgamma(ACA)
002F                  MOP_CEIL              equ    $002F    ;     ACR = std::ceil(ACA)
0030                  MOP_FLOOR             equ    $0030    ;     ACR = std::floor(ACA)
0031                  MOP_TRUNC             equ    $0031    ;     ACR = std::trunc(ACA)
0032                  MOP_ROUND             equ    $0032    ;     ACR = std::round(ACA)
0033                  MOP_LROUND            equ    $0033    ;     ACR = std::lround(ACA)
0034                  MOP_NEARBYINT         equ    $0034    ;     ACR = std::nearbyint(ACA)
0035                  MOP_ILOGB             equ    $0035    ;     ACR = std::ilogb(ACA)
0036                  MOP_LOGB              equ    $0036    ;     ACR = std::logb(ACA)
0037                  MOP_NEXTAFTER         equ    $0037    ;     ACR = std::nextafter(ACA, ACB)
0038                  MOP_COPYSIGN          equ    $0038    ;     ACR = std::copysign(ACA, ACB)
0039                  MOP_LASTOP            equ    $0039    ;   END Math Operation Enumeration
FE85                  MATH_END              equ    $FE85    ; End of Math Co-Processor Register Space
FE86                  MATH_TOP              equ    $FE86    ; Top of Math Co-Processor Register Space
                      ; _______________________________________________________________________
                      
FE86                  HDW_RESERVED_DEVICE   equ    $FE86    ; START: Reserved Register Space
FFF0                  HDW_REG_END           equ    $FFF0    ; 362 bytes reserved for future use.
                      ; _______________________________________________________________________
                      
FFF0                  ROM_VECTS_DEVICE      equ    $FFF0    ; START: Hardware Interrupt Vectors
FFF0                  HARD_EXEC             equ    $FFF0    ; EXEC Hardware Interrupt Vector
FFF2                  HARD_SWI3             equ    $FFF2    ; SWI3 Hardware Interrupt Vector
FFF4                  HARD_SWI2             equ    $FFF4    ; SWI2 Hardware Interrupt Vector
FFF6                  HARD_FIRQ             equ    $FFF6    ; FIRQ Hardware Interrupt Vector
FFF8                  HARD_IRQ              equ    $FFF8    ; IRQ Hardware Interrupt Vector
FFFA                  HARD_SWI              equ    $FFFA    ; SWI / SYS Hardware Interrupt Vector
FFFC                  HARD_NMI              equ    $FFFC    ; NMI Hardware Interrupt Vector
FFFE                  HARD_RESET            equ    $FFFE    ; RESET Hardware Interrupt Vector
                      
                      
                      ; END of memory_map.asm definitions
                      
                      
                      
                      ; sys macro expands to SWI2 with a following command byte
                      sys             macro
                                      swi2
                                      fcb     \1
                                      endm
                      
                      
                      ; *****************************************************************************
                      ; * SYSTEM SOFTWARE VECTORS                                                   *
                      ; *****************************************************************************
0000                  VEC_EXEC        equ     $0000   ; User defined EXEC vector
0002                  VEC_SWI3        equ     $0002   ; SWI3 Software Interrupt Vector
0004                  VEC_SWI2        equ     $0004   ; SWI2 Software Interrupt Vector
0006                  VEC_FIRQ        equ     $0006   ; FIRQ Software Interrupt Vector
0008                  VEC_IRQ         equ     $0008   ; IRQ Software Interrupt Vector
000A                  VEC_SWI         equ     $000A   ; SWI / SYS Software Interrupt Vector
000C                  VEC_NMI         equ     $000C   ; NMI Software Interrupt Vector 
000E                  VEC_RESET       equ     $000E   ; RESET Software Interrupt Vector       
                      
                      ; *****************************************************************************
                      ; * KERNAL ROUTINE SOFTWARE VECTORS                                           *
                      ; *****************************************************************************
0010                  VEC_CLS         equ     $0010   ; CLS function Software Vector
0012                  VEC_CHROUT      equ     $0012   ; Character Out Software Vector
0014                  VEC_NEWLINE     equ     $0014   ; Kernel Newline Software Vector
0016                  VEC_LINEOUT     equ     $0016   ; String to Console Software Vector
0018                  VEC_CSRPOS      equ     $0018   ; Cursor Position Software Vector
001A                  VEC_SCROLL      equ     $001A   ; Scroll Text Screen Software Vector
001C                  VEC_LINEEDIT    equ     $001C   ; Console Line Editor Software Vector
001E                  VEC_GETKEY      equ     $001E   ; Wait for Key Press Software Vector
0020                  VEC_GETHEX      equ     $0020   ; Wait for Hex Character Software Vector
0022                  VEC_GETNUM      equ     $0022   ; Wait for Numeric Character Vector
0024                  VEC_CMPSTR      equ     $0024   ; Compare two strings of arbitrary lengths Vector
0026                  VEC_CMD_PROC    equ     $0026   ; Parse the command entered by the user Vector
0028                  VEC_TBLSEARCH   equ     $0028   ; Table Search and Return index Vector
002A                  VEC_CPY_DWORD   equ     $002A   ; Copy 32-bits from addr X addr Y Vector
002C                  VEC_D_TO_RAWA   equ     $002C   ; Write the D register to RAWA  Vector
002E                  VEC_D_TO_RAWB   equ     $002E   ; Write the D register to RAWB Vector
0030                  VEC_D_TO_RAWR   equ     $0030   ; Write the D register to RAWR Vector 
0032                  VEC_D_TO_INTA   equ     $0032   ; Write the D register to INTA Vector
0034                  VEC_D_TO_INTB   equ     $0034   ; Write the D register to INTB Vector
0036                  VEC_D_TO_INTR   equ     $0036   ; Write the D register to INTR Vector
0038                  VEC_RAWA_TO_D   equ     $0038   ; Read the RAWA float into D Vector
003A                  VEC_RAWB_TO_D   equ     $003A   ; Read the RAWB float into D Vector
003C                  VEC_RAWR_TO_D   equ     $003C   ; Read the RAWD float into D Vector
003E                  VEC_INTA_TO_D   equ     $003E   ; Read the INTA integer into D Vector
0040                  VEC_INTB_TO_D   equ     $0040   ; Read the INTB integer into D Vector
0042                  VEC_INTR_TO_D   equ     $0042   ; Read the INTR integer into D Vector
0044                  VEC_8BIT_MATH   equ     $0044   ; 8-bit integer math Vector
0046                  VEC_DSP_ACA     equ     $0046   ; Send to console the float in ACA Vector
0048                  VEC_DSP_ACB     equ     $0048   ; Send to console the float in ACB Vector
004A                  VEC_DSP_ACR     equ     $004A   ; Send to console the float in ACA Vector
004C                  VEC_DSP_INTA    equ     $004C   ; Send to console the integer in ACA Vector
004E                  VEC_DSP_INTB    equ     $004E   ; Send to console the integer in ACB Vector
0050                  VEC_DSP_INTR    equ     $0050   ; Send to console the integer in ACR Vector
0052                  VEC_WRITE_ACA   equ     $0052   ; Write RAW float X points to into ACA Vector
0054                  VEC_WRITE_ACB   equ     $0054   ; Write RAW float X points to into ACB Vector 
0056                  VEC_WRITE_ACR   equ     $0056   ; Write RAW float X points to into ACR Vector
0058                  VEC_ARG_TO_A    equ     $0058   ; Convert numeric string to binary in A Vector
                      
                      ; *****************************************************************************
                      ; * RESERVED ZERO PAGE KERNAL VARIABLES                                       *
                      ; *****************************************************************************
005A                  _CURSOR_COL     equ     $005A   ; (Byte) current cursor horizontal position
005B                  _CURSOR_ROW     equ     $005B   ; (Byte) current cursor vertical position
005C                  _ATTRIB         equ     $005C   ; (Byte) current character display attribute
005D                  _ANCHOR_COL     equ     $005D   ; (Byte) line edit anchor column
005E                  _ANCHOR_ROW     equ     $005E   ; (Byte) line edit anchor row
005F                  _LOCAL_0        equ     $005F   ; (Byte) used locally for some kernel calls
0060                  _LOCAL_1        equ     $0060   ; (Byte) used locally for some kernel calls
0061                  _LOCAL_2        equ     $0061   ; (Byte) used locally for some kernel calls
0062                  _LOCAL_3        equ     $0062   ; (Byte) used locally for some kernel calls
                      
0000                                  org     SOFT_VECTORS_DEVICE
                      
0000  0000            SVCT_EXEC       fdb     #0      ; VECT_EXEC                                     
0002  0000            SVCT_SWI3       fdb     #0      ; VECT_SWI3             
0004  0000            SVCT_SWI2       fdb     #0      ; VECT_SWI2             
0006  0000            SVCT_FIRQ       fdb     #0      ; VECT_FIRQ             
0008  0000            SVCT_IRQ        fdb     #0      ; VECT_IRQ              
000A  0000            SVCT_SWI        fdb     #0      ; VECT_SWI              
000C  0000            SVCT_NMI        fdb     #0      ; VECT_NMI              
000E  0000            SVCT_RESET      fdb     #0      ; VECT_RESET    
                      
                      
                      
                      ; ---------------------------------------------------------------------
                      
F000                                  org     KERNEL_START
                      
F000  203B            KRNL_START      bra     KRNL_BEGIN
                      
F002  4B65726E656C2056657273696F6E3A2000 krnl_vers_label         fcn     "Kernel Version: "
F013  302E302E3100    krnl_vers_number        fcn     "0.0.1"
                      
                      
                      * ; *****************************************************************************
                      * ; * KERNEL JUMP VECTORS                                                       *
                      * ; *****************************************************************************
                      * KRNL_EXEC     jmp     [VEC_EXEC]      ; The user EXEC vector
                      * KRNL_SWI3     jmp     [VEC_SWI3]      ; SWI3 Software Interrupt Vector        
                      * KRNL_SWI2     jmp     [VEC_SWI2]      ; SWI2 Software Interrupt Vector
                      * KRNL_FIRQ     jmp     [VEC_FIRQ]      ; FIRQ Software Interrupt Vector
                      * KRNL_IRQ      jmp     [VEC_IRQ]       ; IRQ Software Interrupt Vector
                      * KRNL_SWI      jmp     [VEC_SWI]       ; SWI / SYS Software Interrupt Vector
                      * KRNL_NMI      jmp     [VEC_NMI]       ; NMI Software Interrupt Vector
                      * KRNL_RESET    jmp     [VEC_RESET]     ; RESET Software Interrupt Vector       
                      
                      ; *****************************************************************************
                      ; * DEFAULT VECTORS                                                           *
                      ; *****************************************************************************
F019  7EF019          EXEC_start      jmp     EXEC_start      ; EXEC program
F01C  7EF01C          SWI3_start      jmp     SWI3_start      ; SWI3 Implementation
F01F  7EF01F          SWI2_start      jmp     SWI2_start      ; SYS (SWI2) Implementation
F022  7EF022          FIRQ_start      jmp     FIRQ_start      ; FIRQ Implementation
F025  7EF025          IRQ_start       jmp     IRQ_start       ; IRQ Implementation
F028  7EF028          SWI_start       jmp     SWI_start       ; SWI / SYS Implementation
F02B  7EF02B          NMI_start       jmp     NMI_start       ; NMI Implementation
F02E  7EF02E          RESET_start     jmp     RESET_start     ; RESET Implementation
                      
                      ; *****************************************************************************
                      ; * KERNAL ROUTINE SOFTWARE VECTORS                                           *
                      ; *****************************************************************************
F031                  SYSTEM_DATA_START
F031  F0E0                            fdb     STUB_CLS        ; VECT_CLS      
F033  F0F7                            fdb     STUB_CHROUT     ; VECT_CHROUT   
F035  F12A                            fdb     STUB_NEWLINE    ; VECT_NEWLINE  
F037  F15C                            fdb     STUB_LINEOUT    ; VECT_LINEOUT  
F039  F174                            fdb     STUB_CSRPOS     ; VECT_CSRPOS   
F03B  F190                            fdb     STUB_SCROLL     ; VECT_SCROLL   
                                      * fdb   STUB_LINEEDIT   ; VECT_LINEEDIT 
                                      * fdb   STUB_GETKEY     ; VECT_GETKEY   
                                      * fdb   STUB_GETHEX     ; VECT_GETHEX   
                                      * fdb   STUB_GETNUM     ; VECT_GETNUM   
                                      * fdb   STUB_CMPSTR     ; VECT_CMPSTR   
                                      * fdb   STUB_CMD_PROC   ; VECT_CMD_PROC 
                                      * fdb   STUB_TBLSEARCH  ; VECT_TBLSEARCH        
                                      * fdb   STUB_CPY_DWORD  ; VECT_CPY_DWORD        
                                      * fdb   STUB_D_TO_RAWA  ; VECT_D_TO_RAWA        
                                      * fdb   STUB_D_TO_RAWB  ; VECT_D_TO_RAWB        
                                      * fdb   STUB_D_TO_RAWR  ; VECT_D_TO_RAWR        
                                      * fdb   STUB_D_TO_INTA  ; VECT_D_TO_INTA        
                                      * fdb   STUB_D_TO_INTB  ; VECT_D_TO_INTB        
                                      * fdb   STUB_D_TO_INTR  ; VECT_D_TO_INTR        
                                      * fdb   STUB_RAWA_TO_D  ; VECT_RAWA_TO_D        
                                      * fdb   STUB_RAWB_TO_D  ; VECT_RAWB_TO_D        
                                      * fdb   STUB_RAWR_TO_D  ; VECT_RAWR_TO_D        
                                      * fdb   STUB_INTA_TO_D  ; VECT_INTA_TO_D        
                                      * fdb   STUB_INTB_TO_D  ; VECT_INTB_TO_D        
                                      * fdb   STUB_INTR_TO_D  ; VECT_INTR_TO_D        
                                      * fdb   STUB_8BIT_MATH  ; VECT_8BIT_MATH        
                                      * fdb   STUB_DSP_ACA    ; VECT_DSP_ACA  
                                      * fdb   STUB_DSP_ACB    ; VECT_DSP_ACB  
                                      * fdb   STUB_DSP_ACR    ; VECT_DSP_ACR  
                                      * fdb   STUB_DSP_INTA   ; VECT_DSP_INTA 
                                      * fdb   STUB_DSP_INTB   ; VECT_DSP_INTB 
                                      * fdb   STUB_DSP_INTR   ; VECT_DSP_INTR 
                                      * fdb   STUB_WRITE_ACA  ; VECT_WRITE_ACA        
                                      * fdb   STUB_WRITE_ACB  ; VECT_WRITE_ACB        
                                      * fdb   STUB_WRITE_ACR  ; VECT_WRITE_ACR        
                                      * fdb   STUB_ARG_TO_A   ; VECT_ARG_TO_A 
F03D                  SYSTEM_DATA_END
                      
                      
                      ; ---------------------------------------------------------------------
                      
F03D                  KRNL_BEGIN      ; warm reset?
F03D  FC000E                          ldd     SOFT_RESET
F040  10830000                        cmpd    #0
F044  2704                            beq     KRNL_COLD
F046  6E9F000E                        jmp     [SOFT_RESET]
                                              
F04A                  KRNL_COLD       ; cold reset
F04A  8EFFF0                          ldx     #KRNL_HARD_VECT
F04D  CE0000                          ldu     #SOFT_VECTORS_DEVICE
F050  EC81            1               ldd     ,x++
F052  EDC1                            std     ,u++
F054  8C0000                          cmpx    #KRNL_HARD_VECT_END
F057  2DF7                            blt     1b
F059  CCF081                          ldd     #KRNL_WARM
F05C  FD000E                          std     SOFT_RESET
                      
                                      ; ...
                                      ; clear out system memory
F05F  8E0010                          ldx     #SYSTEM_MEMORY_DEVICE
F062  CE0400                          ldu     #VIDEO_START
F065  CC0000                          ldd     #$0000
F068  AFC4            1               stx     ,u                      ; cycle first character to show progress
F06A  ED81                            std     ,x++
F06C  8CF000                          cmpx    #KERNEL_ROM_DEVICE
F06F  26F7                            bne     1b
                      
                                      ; initialize the system 
F071  8EF031                          ldx     #SYSTEM_DATA_START
F074  108E0010                        ldy     #$0010
F078  A680            2               lda     ,x+
F07A  A7A0                            sta     ,y+
F07C  8CF03D                          cmpx    #SYSTEM_DATA_END
F07F  2DF7                            blt     2b                      
                      
                      
                                              ; ...
F081                  KRNL_WARM               ; common start up code
                                              ;
                                              ; for now simply set the SP
F081  10CE0400                                lds     #SSTACK_TOP
                                              ; ...
                      
F085  864B                                    lda     #$4B                    ; $4B = green on dk.green
F087  B7005C                                  sta     _ATTRIB
                      
                                              ; set default video
F08A  86F1                                    lda     #%11110001
F08C  C660                                    ldb     #%01100000
F08E  FDFE0B                                  std     GPU_OPTIONS
                                              ;cmpd   GPU_OPTIONS
                      
                                              * ; display some text
                                              * ldx   #krnl_vers_label
                                              * jsr   KRNL_LINEOUT
                      
                                              ; make a system call
F091                                          sys     #$00
F091  103F                            swi2
F093  00                              fcb     \1
                      
F094  7F005A                                  clr     _CURSOR_COL
F097  7F005B                                  clr     _CURSOR_ROW
F09A  8EF002                                  ldx     #krnl_vers_label
F09D  BDF158                                  jsr     KRNL_LINEOUT
F0A0  8EF013                                  ldx     #krnl_vers_number
F0A3  BDF158                                  jsr     KRNL_LINEOUT
                      
F0A6  7EF0A6          krnl_warm_reset_inf     jmp     krnl_warm_reset_inf                     
                      
                      
                      
                      ; ----------------------  MAIN STUFF  --------------------------------------
                      
                      
                      
                      
                                              ; cycle video memory
F0A9                  krnl_swi2_random_garbage                        
F0A9  CC0100                                  ldd     #$0100
F0AC  8E0400          1                       ldx     #VIDEO_START            
F0AF  C30001                                  addd    #1
F0B2  ED81            2                       std     ,x++
F0B4  C30001                                  addd    #1
F0B7  BCFE0D                                  cmpx    GPU_VIDEO_MAX
F0BA  2DF6                                    blt     2b
F0BC  20EE                                    bra     1b
                      
                      
                      
                      
                      ; ** krnl_swi2 *******************************************************************
                      ; * 
                      ; * System Call Handler: 
                      ; *     References the byte immediately following the SWI2 instruction and
                      ; *     dispatches to the appropriate system call based on that value.
                      ; *
                      ; *
                      ; *********************************************************************************
F0BE  F0DC            krnl_swi2_call_vector   fdb     KRNL_CLS                        ; $00 clear screen
F0C0  F0F3                                    fdb     KRNL_CHROUT                     ; $01 CHROUT
F0C2  F158                                    fdb     KRNL_LINEOUT                    ; $02 LINEOUT
F0C4  F0A9                                    fdb     krnl_swi2_random_garbage        ; $N random garbage
F0C6                  krnl_swi2_call_end                              
                      
                      
F0C6                  SYS_Handler             ; increment the return address on the stack past the command byte
F0C6  EE6A                                    ldu     $000a,s
F0C8  E6C4                                    ldb     0,u
F0CA  3341                                    leau    1,u
F0CC  EF6A                                    stu     $000a,s
F0CE  8EF0BE                                  ldx     #krnl_swi2_call_vector
F0D1  58                                      lslb
F0D2  3085                                    leax    b,x
F0D4  8CF0C6                                  cmpx    #krnl_swi2_call_end
F0D7  2C02                                    bge     SWI2_start_done
F0D9  AD94                                    jsr     [,x]
F0DB  3B              SWI2_start_done         rti
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CLS                                                                  *
                      ; *     Clears the currently displayed screen buffer                          *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: Screen will be cleared with spaces with the color     *
                      ; *     stored in _ATTRIB.                                                    *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F0DC  6E9F0010        KRNL_CLS        jmp     [VEC_CLS]       ; proceed through the software vector
F0E0  3416            STUB_CLS        pshs    d,x             ; save the used registers onto the stack
F0E2  F6005C                          ldb     _ATTRIB         ; fetch the current color attribute
F0E5  8620                            lda     #' '            ; the space character
F0E7  8E0400                          ldx     #VIDEO_START    ; index the start of the video buffer
F0EA  ED81            1               std     ,x++            ; store a character to the buffer
F0EC  BCFE0D                          cmpx    GPU_VIDEO_MAX   ; are we at the end yet?
F0EF  2DF9                            blt     1b              ; nope, keep storing characters
F0F1  3596                            puls    d,x,pc          ; cleanup and return
                      
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CHROUT                                                               *
                      ; *     Outputs a character to the console at the current cursor              *
                      ; *     position. This routine should update the cursors postion              *
                      ; *     and handle text scrolling as needed.                                  *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: A = Character to be displayed                         *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F0F3  6E9F0012        KRNL_CHROUT     jmp     [VEC_CHROUT]    ; proceed through the software vector
F0F7  3417            STUB_CHROUT     pshs    d,x,cc          ; save the used registers onto the stack
F0F9  F6005C                          ldb     _ATTRIB         ; load the current color attribute
F0FC  4D              K_CHROUT_1      tsta                    ; is A a null?
F0FD  2725                            beq     K_CHROUT_DONE   ;    A is null, just return and do nothing              
F0FF  810A                            cmpa    #$0A            ; is it a newline character?
F101  2605                            bne     K_CHROUT_2      ; nope, don't do a newline
F103  BDF126                          jsr     KRNL_NEWLINE    ; advance the cursor 
F106  201C                            bra     K_CHROUT_DONE   ; clean up and return
F108  8109            K_CHROUT_2      cmpa    #$09            ; is it a tab character?
F10A  2605                            bne     K_CHROUT_0      ; nope, don't do a tab
F10C  BDF142                          jsr     KRNL_TAB        ; tab the character position
F10F  2013                            bra     K_CHROUT_DONE   ; clean up and return
F111  BDF170          K_CHROUT_0      jsr     KRNL_CSRPOS     ; position X at the cursor position
F114  ED84                            std     ,x              ; display the character/attribute combo
F116  7C005A                          inc     _CURSOR_COL     ; increment current cursor column position
F119  B6005A                          lda     _CURSOR_COL     ; load current cursor column position                                   
F11C  B1FE13                          cmpa    GPU_TCOLS       ; compare with the current screen columns
F11F  2D03                            blt     K_CHROUT_DONE   ; if the csr column is okay, we're done
F121  BDF126                          jsr     KRNL_NEWLINE    ; perform a new line
F124  3597            K_CHROUT_DONE   puls    d,x,cc,pc       ; cleanup and return
                      
                      ; *****************************************************************************
                      ; * KRNL_NEWLINE                                                              *
                      ; *     Perfoms a CR/LF ($0A) on the console. Advances the current            *
                      ; *     cursor position and scrolls the console if needed.                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F126  6E9F0014        KRNL_NEWLINE    jmp     [VEC_NEWLINE]   ; proceed through the software vector
F12A  3416            STUB_NEWLINE    pshs    D,X             ; save the used registers onto the stack
F12C  7F005A                          clr     _CURSOR_COL     ; carrage return (move to left edge)
F12F  7C005B                          inc     _CURSOR_ROW     ; increment the cursors row
F132  B6005B                          lda     _CURSOR_ROW     ; load the current row
F135  B1FE14                          cmpa    GPU_TROWS       ; compared to the current screen rows
F138  2D06                            blt     K_NEWLINE_DONE  ; clean up and return if less than
F13A  7A005B                          dec     _CURSOR_ROW     ; move the cursor the the bottom row
F13D  BDF18C                          jsr     KRNL_SCROLL     ; scroll the text screen up one line
F140  3596            K_NEWLINE_DONE  puls    D,X,PC          ; restore the saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_TAB                                                                  *
                      ; *     Perfoms a tab ($0A) on the console. Advances the current              *
                      ; *     cursor position and scrolls the console if needed.                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F142                  KRNL_TAB  ; Tab ($09)
F142  3404                            pshs    b                       ; save B
F144  F6005A                          ldb     _CURSOR_COL             ; Fetch the current cursor col
F147  CB04                            addb    #4                      ; Move cursor by 4 spaces
F149  C4FC                            andb    #%11111100              ; Align to the next tab stop
F14B  F7005A                          stb     _CURSOR_COL             ; update the cursor column
F14E  F1FE13                          cmpb    GPU_TCOLS               ; Ensure column is within bounds
F151  2D03                            blt     K_TAB_DONE              ; Within bounds, we're done
F153  BDF126                          jsr     KRNL_NEWLINE            ; Handle line wrapping
F156  3584            K_TAB_DONE      puls    B,PC                    ; cleanup and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_LINEOUT                                                              *
                      ; *     Outputs a string to the console                                       *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X = String starting address                           *
                      ; *                         (null or neg terminated)                          *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F158  6E9F0016        KRNL_LINEOUT    jmp     [VEC_LINEOUT]   ; proceed through the software vector
F15C  3456            STUB_LINEOUT    pshs    D,U,X           ; save the used registers onto the stack
F15E  1F13                            tfr     x,u             ; move X to U
F160  BDF170                          jsr     KRNL_CSRPOS     ; set X to the cursor position 
F163  A6C0            K_LINEOUT_0     lda     ,u+             ; fetch the next character
F165  2707                            beq     K_LINEOUT_DONE  ; cleanup and return if null-terminator         
F167  BDF0F3                          jsr     KRNL_CHROUT     ; send the character to the console
F16A  3001                            leax    1,x             ; point to the next character
F16C  20F5                            bra     K_LINEOUT_0     ; continue looping until done
F16E  35D6            K_LINEOUT_DONE  puls    D,U,X,pc        ; restore the saved registers and return                
                      
                      ; *****************************************************************************
                      ; * KRNL_CSRPOS                                                              *
                      ; *     Loads into X the cursor position                                      *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    X = The address within the text                       *
                      ; *                         where the cursor is positioned.                   *   
                      ; *                     All other registers preserved.                        *
                      ; *****************************************************************************
F170  6E9F0018        KRNL_CSRPOS     jmp     [VEC_CSRPOS]    ; proceed through the software vector
F174  3406            STUB_CSRPOS     pshs    d               ; save the used registers onto the stack
F176  B6005B                          lda     _CURSOR_ROW     ; current cursor row
F179  F6FE13                          ldb     GPU_TCOLS       ; current text columns
F17C  58                              lslb                    ; times two (account for the attribute)
F17D  3D                              mul                     ; row * columns
F17E  8E0400                          ldx     #VIDEO_START    ; the buffer starting address
F181  308B                            leax    d,x             ; add the video base address
F183  F6005A                          ldb     _CURSOR_COL     ; load the current cursor column
F186  58                              lslb                    ; times two (account for the attribute)
F187  4F                              clra                    ; don't let B become negative, use D
F188  308B                            leax    d,x             ; add the column to the return address
F18A  3586                            puls    d,pc            ; restore the saved registers and return
                      
                      ; *****************************************************************************
                      ; * KRNL_SCROLL                                                               *
                      ; *     Scroll the text screen up one line and blank the bottom line.         *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F18C  6E9F001A        KRNL_SCROLL     jmp     [VEC_SCROLL]    ; proceed through the software vector
F190  3456            STUB_SCROLL     pshs    d,x,u           ; save the used registers onto the stack
F192  8E0400                          ldx     #VIDEO_START    ; set X to the start of the video buffer
F195  1F13                            tfr     x,u             ; copy X into U
F197  F6FE13                          ldb     GPU_TCOLS       ; B = Screen Columns
F19A  58                              lslb                    ; account for the attribute byte
F19B  4F                              clra                    ; MSB of D needs to not be negative
F19C  33CB                            leau    d,u             ; U is now one line below X
F19E  ECC1            K_SCROLL_0      ldd     ,u++            ; load a character from where U points
F1A0  ED81                            std     ,x++            ; store it to where X points
F1A2  11B3FE0D                        cmpu    GPU_VIDEO_MAX   ; has U exceeded the screen buffer
F1A6  2DF6                            blt     K_SCROLL_0      ; continue looping of not
F1A8  8620                            lda     #' '            ; set SPACE as the current character
F1AA  A781            K_SCROLL_1      sta     ,x++            ; and store it to where X points
F1AC  BCFE0D                          cmpx    GPU_VIDEO_MAX   ; continue looping until the bottom ...
F1AF  2DF9                            blt     K_SCROLL_1      ; ... line has been cleared
F1B1  7DFE42                          tst     EDT_ENABLE      ; are we using the line editor?
F1B4  2703                            beq     K_SCROLL_DONE   ; nope, just clean up and return
F1B6  7A005E                          dec     _ANCHOR_ROW     ; yup, decrease the anchor row by one
F1B9  35D6            K_SCROLL_DONE   puls    d,x,u,pc        ; restore the registers and return
                      
                      
                      
                      
                      
                      
                      ; *****************************************************************************
                      ; * SUBROUTINE_TEMPLATE                                                       *
                      ; *     xxxxxxxxxxxxxxxxxx                                                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: A = xxxxxxxxxxx                                       *
                      ; *                     B = xxxxxxxxxxx                                       *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    D = Result                                            *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *                     All other registers preserved                         *
                      ; *****************************************************************************
                      
                      
                      
                      
                      
                      
                      * ; *****************************************************************************
                      * ; * ROM BASED HARDWARE VECTORS                                                *
                      * ; *****************************************************************************
FFF0                          org     ROM_VECTS_DEVICE
FFF0                  KRNL_HARD_VECT                  
FFF0  F019                    fdb     EXEC_start      ; HARD_RSRVD       EXEC Interrupt Vector
FFF2  F01C                    fdb     SWI3_start      ; HARD_SWI3        SWI3 Hardware Interrupt Vector
FFF4  F0C6                    fdb     SYS_Handler     ; HARD_SWI2        SWI2 Hardware Interrupt Vector
FFF6  F022                    fdb     FIRQ_start      ; HARD_FIRQ        FIRQ Hardware Interrupt Vector
FFF8  F025                    fdb     IRQ_start       ; HARD_IRQ         IRQ Hardware Interrupt Vector
FFFA  F028                    fdb     SWI_start       ; HARD_SWI         SWI / SYS Hardware Interrupt Vector
FFFC  F02B                    fdb     NMI_start       ; HARD_NMI         NMI Hardware Interrupt Vector
FFFE  F000                    fdb     KRNL_START      ; HARD_RESET       RESET Hardware Interrupt Vector
0000                  KRNL_HARD_VECT_END
