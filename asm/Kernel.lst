                      ;*** kernel.asm ************************
                       *      _  __                    _                           
                       *     | |/ /___ _ __ _ __   ___| |       __ _ ___ _ __ ___  
                       *     | ' // _ \ '__| '_ \ / _ \ |      / _` / __| '_ ` _ \ 
                       *     | . \  __/ |  | | | |  __/ |  _  | (_| \__ \ | | | | |
                       *     |_|\_\___|_|  |_| |_|\___|_| (_)  \__,_|___/_| |_| |_|
                      ;*                
                      ;* Released under the GPL v3.0 License.
                      ;* Original Author: Jay Faries (warte67)                                           
                      ;*****************************
                      
                      
0000                                  INCLUDE "Kernel_Header.asm"
                      ; ***** kernel_header.asm ************************************************************************
                      ; *      _  __                    _     _   _                _
                      ; *     | |/ /___ _ __ _ __   ___| |   | | | | ___  __ _  __| | ___ _ __    __ _ ___ _ __ ___
                      ; *     | ' // _ \ '__| '_ \ / _ \ |   | |_| |/ _ \/ _` |/ _` |/ _ \ '__|  / _` / __| '_ ` _ \
                      ; *     | . \  __/ |  | | | |  __/ |   |  _  |  __/ (_| | (_| |  __/ |_   | (_| \__ \ | | | | |
                      ; *     |_|\_\___|_|  |_| |_|\___|_|___|_| |_|\___|\__,_|\__,_|\___|_(_)   \__,_|___/_| |_| |_|
                      ; *                               |_____|
                      ; *
                      ; ************************************************************************************************
                      
0000                                      INCLUDE "Memory_Map.asm"
                      ;*** Memory_Map.asm *************************************************
                      ;*    __  __                                     __  __                                 
                      ;*   |  \/  |                                   |  \/  |                                
                      ;*   | \  / | ___ _ __ ___   ___  _ __ _   _    | \  / | __ _ _ __   __ _ ___ _ __ ___  
                      ;*   | |\/| |/ _ \ '_ ` _ \ / _ \| '__| | | |   | |\/| |/ _` | '_ \ / _` / __| '_ ` _ \ 
                      ;*   | |  | |  __/ | | | | | (_) | |  | |_| |   | |  | | (_| | |_) | (_| \__ \ | | | | |
                      ;*   |_|  |_|\___|_| |_| |_|\___/|_|   \__, |   |_|  |_|\__,_| .__(_)__,_|___/_| |_| |_|
                      ;*                                      __/ |_____           | |                        
                      ;*                                     |___/______|          |_|                        
                      ;*
                      ;* 6809 Assembly Memory Map Definition File
                      ;*
                      ;* Released under the GPL v3.0 License.
                      ;* Original Author: Jay Faries (warte67)
                      ;*
                      ;************************************
                      
                      
                      
                      ;   **********************************************
                      ;   * Allocated 64k Memory Mapped System Symbols *
                      ;   **********************************************
                      ;
                      
0000                  SOFT_VECTORS_DEVICE   equ    $0000    ; START: Software Interrupt Vectors
0000                  SOFT_EXEC             equ    $0000    ; Exec Software Interrupt Vector
0002                  SOFT_SWI3             equ    $0002    ; SWI3 Software Interrupt Vector
0004                  SOFT_SWI2             equ    $0004    ; SWI2 Software Interrupt Vector
0006                  SOFT_FIRQ             equ    $0006    ; FIRQ Software Interrupt Vector
0008                  SOFT_IRQ              equ    $0008    ; IRQ Software Interrupt Vector
000A                  SOFT_SWI              equ    $000A    ; SWI / SYS Software Interrupt Vector
000C                  SOFT_NMI              equ    $000C    ; NMI Software Interrupt Vector
000E                  SOFT_RESET            equ    $000E    ; RESET Software Interrupt Vector
                      ; _______________________________________________________________________
                      
0010                  SYSTEM_MEMORY_DEVICE  equ    $0010    ; START: System Memory
0010                  ZERO_PAGE             equ    $0010    ; Zero Page System and User Variables
00FF                  ZERO_PAGE_END         equ    $00FF    ; Zero Page System and User Variables
0100                  EDT_BUFFER            equ    $0100    ; START: Line Edit Character Buffer
017F                  KEY_END               equ    $017F    ; END: Line Edit Character Buffer
0180                  FIO_BUFFER            equ    $0180    ; START: Input/Output Buffer
01FF                  FIO_BFR_END           equ    $01FF    ; END: Input/Output Buffer
0200                  SYSTEM_STACK          equ    $0200    ; Bottom of System Stack Spcace
03FF                  SSTACK_END            equ    $03FF    ; END: System Stack Space
0400                  SSTACK_TOP            equ    $0400    ; TOP: System Stack Space
                      ; _______________________________________________________________________
                      
0400                  VIDEO_BUFFER_DEVICE   equ    $0400    ; START: Video Buffer (8K)
0400                  VIDEO_START           equ    $0400    ; Start of standard video buffer
23FF                  VIDEO_END             equ    $23FF    ; End of standard video buffer
2400                  VIDEO_TOP             equ    $2400    ; Top of standard video buffer
                      ; _______________________________________________________________________
                      
2400                  USER_MEMORY_DEVICE    equ    $2400    ; START: User Memory (34K)
2400                  USER_RAM              equ    $2400    ; User Accessable RAM
AFFF                  USER_RAM_END          equ    $AFFF    ; End User Accessable RAM
B000                  USER_RAM_TOP          equ    $B000    ; Top User Accessable RAM
                      ; _______________________________________________________________________
                      
B000                  BANKED_MEMORY_REGION  equ    $B000    ; START: Banked Memory Region (16K)
B000                  BANKMEM_ONE           equ    $B000    ; Banked Memory Page One (8K)
D000                  BANKMEM_TWO           equ    $D000    ; Banked Memory Page Two (8K)
EFFF                  BANKMEM_END           equ    $EFFF    ; End of Banked Memory Region
F000                  BANKMEM_TOP           equ    $F000    ; TOP of Banked Memory Region
                      ; _______________________________________________________________________
                      
F000                  KERNEL_ROM_DEVICE     equ    $F000    ; START: Kernel Rom (3.5K)
F000                  KERNEL_START          equ    $F000    ; Start of Kernel Rom Space
FDFF                  KERNEL_END            equ    $FDFF    ; End of Kernel Rom Space
FE00                  KERNEL_TOP            equ    $FE00    ; Top of Kernel Rom Space
                      ; _______________________________________________________________________
                      
FE00                  SYS_DEVICE            equ    $FE00    ; START: System and Debug Hardware Registers:
FE00                  SYS_BEGIN             equ    $FE00    ; Start of System Registers
FE00                  SYS_STATE             equ    $FE00    ; (Byte) System State Register
                                                            ; SYS_STATE: ABCD.SSSS                          
                                                            ; - bit  7   = Error: Standard Buffer Overflow  
                                                            ; - bit  6   = Error: Extended Buffer Overflow  
                                                            ; - bit  5   = Error: Reserved                  
                                                            ; - bit  4   = Error: Reserved                  
                                                            ; - bits 0-3 = CPU Speed (0-15):                
                                                            ;    0 ($0)  = CPU Clock   10 kHz 
                                                            ;    1 ($1)  = CPU Clock   25 kHz 
                                                            ;    2 ($2)  = CPU Clock   50 kHz 
                                                            ;    3 ($3)  = CPU Clock   75 kHz 
                                                            ;    4 ($4)  = CPU Clock  100 kHz 
                                                            ;    5 ($5)  = CPU Clock  150 kHz 
                                                            ;    6 ($6)  = CPU Clock  225 kHz 
                                                            ;    7 ($7)  = CPU Clock  350 kHz 
                                                            ;    8 ($8)  = CPU Clock  500 kHz 
                                                            ;    9 ($9)  = CPU Clock  750 kHz 
                                                            ;   10 ($A)  = CPU Clock  900 kHz 
                                                            ;   11 ($B)  = CPU Clock 1000 khz 
                                                            ;   12 ($C)  = CPU Clock 2000 khz 
                                                            ;   13 ($D)  = CPU Clock 3000 khz 
                                                            ;   14 ($E)  = CPU Clock 4000 khz 
                                                            ;   15 ($F)  = CPU Clock ~10.0 mhz. (unmetered) 
                                                            ; 
FE01                  SYS_SPEED             equ    $FE01    ; (Word) Average CPU Clock Speed (Read Only)
FE03                  SYS_CLOCK_DIV         equ    $FE03    ; (Byte) 60 hz Clock Divider Register (Read Only)
                                                            ; - bit 7: 0.546875 hz
                                                            ; - bit 6: 1.09375 hz
                                                            ; - bit 5: 2.1875 hz
                                                            ; - bit 4: 4.375 hz
                                                            ; - bit 3: 8.75 hz
                                                            ; - bit 2: 17.5 hz
                                                            ; - bit 1: 35.0 hz
                                                            ; - bit 0: 70.0 hz
                                                            ; 
FE04                  SYS_UPDATE_COUNT      equ    $FE04    ; (DWord) Update Count (Read Only)
FE08                  SYS_DBG_BRK_ADDR      equ    $FE08    ; (Word) Address of current debug breakpoint
FE0A                  SYS_DBG_FLAGS         equ    $FE0A    ; (Byte) Debug Specific Hardware Flags:
                                                            ; - bit 7: Debug Enable
                                                            ; - bit 6: Single Step Enable
                                                            ; - bit 5: Clear All Breakpoints
                                                            ; - bit 4: Update Breakpoint at DEBUG_BRK_ADDR
                                                            ; - bit 3: FIRQ  (on low {0} to high {1} edge)
                                                            ; - bit 2: IRQ   (on low {0} to high {1} edge)
                                                            ; - bit 1: NMI   (on low {0} to high {1} edge)
                                                            ; - bit 0: RESET (on low {0} to high {1} edge)
                                                            ; 
FE0A                  SYS_END               equ    $FE0A    ; End of System Registers
FE0B                  SYS_TOP               equ    $FE0B    ; Top of System Registers
                      ; _______________________________________________________________________
                      
FE0B                  GPU_DEVICE            equ    $FE0B    ; START: GPU Device Hardware Registers
FE0B                  GPU_MODE              equ    $FE0B    ; 
FE0B                  GPU_MODE_MSB          equ    $FE0B    ; (Byte) Graphics Display Mode
                                                            ; - bit  7   = Extended Display Enable:
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bit  6   = (reserved)
                                                            ; - bits 4-5 = Extended Color Depth:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bit  3   = Extended Rendering Mode
                                                            ;               0: Tilemap Display
                                                            ;               1: Bitmap Display
                                                            ; - bit  2   = Emulation Screen Mode
                                                            ;               0: Windowed
                                                            ;               1: Fullscreen
                                                            ; - bit  1   = VSync Enable
                                                            ;               0: Disabled
                                                            ;               1: Enabled
                                                            ; - bit  0   = Presentation
                                                            ;               0: Letterbox
                                                            ;               1: Overscan / Stretch
                                                            ; 
FE0C                  GPU_MODE_LSB          equ    $FE0C    ; - bit  7   = Standard Display Enable
                                                            ;              0: Disabled
                                                            ;              1: Enabled
                                                            ; - bit  6    = (reserved)
                                                            ; - bits 4-5 = Standard Bitmap Color Depth:
                                                            ;               00: 2-Colors
                                                            ;               01: 4-Colors
                                                            ;               10: 16-Colors
                                                            ;               11: 256-Colors
                                                            ; - bit  3    = Standard Bitmap:
                                                            ;               0: Text Display
                                                            ;               1: Bitmap Display
                                                            ; MODE (bits 0-2):
                                                            ; - bit  2    = 0: 320/256 width,  1: 160/128 width
                                                            ; - bit  1    = 0: 200/160 height, 1: 160/80 height
                                                            ; - bit  0    = Base Resolution: 0:320x200, 1:256x160
                                                            ; 
                                                            ;               Text Mode Table:
                                                            ;    | MODE | COLUMNS |  ROWS  | BUFFER |
                                                            ;    |:----:|:-------:|:------:|:------:|
                                                            ;    |  $00 |    40   |   25   |  2000  |
                                                            ;    |  $01 |    32   |   20   |  1280  |
                                                            ;    |  $02 |    40   |   12   |   960  |
                                                            ;    |  $03 |    32   |   10   |   640  |
                                                            ;    |  $04 |    20   |   25   |  1000  |
                                                            ;    |  $05 |    16   |   20   |   640  |
                                                            ;    |  $06 |    20   |   12   |   480  |
                                                            ;    |  $07 |    16   |   10   |   320  |
                                                            ; 
                                                            ;         Bitmap Display Mode Table:
                                                            ; | MODE | WIDTH | HEIGHT | COLORS | BUFFER |
                                                            ; |------|-------|--------|--------|--------|
                                                            ; | $00  |  320  |   200  |    2   |  8000  |
                                                            ; | $01  |  256  |   160  |    2   |  5120  |
                                                            ; | $02  |  320  |   100  |    2   |  4000  |
                                                            ; | $03  |  256  |    80  |    2   |  2560  |
                                                            ; | $04  |  160  |   200  |    2   |  4000  |
                                                            ; | $05  |  128  |   160  |    2   |  2560  |
                                                            ; | $06  |  160  |   100  |    2   |  2000  |
                                                            ; | $07  |  128  |    80  |    2   |  1280  |
                                                            ; | $00  |  320  |   200  |    4   | 16000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |    4   | 10240  | (bgnd only)
                                                            ; | $02  |  320  |   100  |    4   |  8000  |
                                                            ; | $03  |  256  |    80  |    4   |  5120  |
                                                            ; | $04  |  160  |   200  |    4   |  8000  |
                                                            ; | $05  |  128  |   160  |    4   |  5120  |
                                                            ; | $06  |  160  |   100  |    4   |  4000  |
                                                            ; | $07  |  128  |    80  |    4   |  2560  |
                                                            ; | $00  |  320  |   200  |   16   | 32000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |   16   | 20480  | (bgnd only)
                                                            ; | $02  |  320  |   100  |   16   | 16000  | (bgnd only)
                                                            ; | $03  |  256  |    80  |   16   | 10240  | (bgnd only)
                                                            ; | $04  |  160  |   200  |   16   | 16000  | (bgnd only)
                                                            ; | $05  |  128  |   160  |   16   | 10240  | (bgnd only)
                                                            ; | $06  |  160  |   100  |   16   |  8000  |
                                                            ; | $07  |  128  |    80  |   16   |  5120  |
                                                            ; | $00  |  320  |   200  |  256   | 64000  | (bgnd only)
                                                            ; | $01  |  256  |   160  |  256   | 40960  | (bgnd only)
                                                            ; | $02  |  320  |   100  |  256   | 32000  | (bgnd only)
                                                            ; | $03  |  256  |    80  |  256   | 20480  | (bgnd only)
                                                            ; | $04  |  160  |   200  |  256   | 32000  | (bgnd only)
                                                            ; | $05  |  128  |   160  |  256   | 20480  | (bgnd only)
                                                            ; | $06  |  160  |   100  |  256   | 16000  | (bgnd only)
                                                            ; | $07  |  128  |    80  |  256   | 10240  | (bgnd only)
                                                            ; 
FE0D                  GPU_VIDEO_MAX         equ    $FE0D    ; (Word) Video Buffer Maximum (Read Only)
                                                            ; Note: This will change to reflect
                                                            ;       the size of the last cpu
                                                            ;       accessible memory location
                                                            ;       of the currently active
                                                            ;       standard video mode.
                                                            ; 
FE0F                  GPU_HRES              equ    $FE0F    ; (Word) Horizontal Pixel Resolution (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       pixel columns for bitmap modes.
                                                            ; 
FE11                  GPU_VRES              equ    $FE11    ; (Word) Vertical Pixel Resolution (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       pixel rows for bitmap modes.
                                                            ; 
FE13                  GPU_TCOLS             equ    $FE13    ; (Byte) Text Horizontal Columns (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       glyph columns for text modes.
                                                            ; 
FE14                  GPU_TROWS             equ    $FE14    ; (Byte) Text Vertical Rows (Read Only)
                                                            ; Note: This will reflect the number of
                                                            ;       glyph rows for text modes.
                                                            ; 
FE15                  GPU_PAL_INDEX         equ    $FE15    ; (Byte) Color Palette Index
                                                            ; Note: Use this register to set the
                                                            ;       index into the Color Palette.
                                                            ;       Set this value prior referencing
                                                            ;       the color data (GPU_PAL_COLOR).
                                                            ; 
FE16                  GPU_PAL_COLOR         equ    $FE16    ; (Word) Color Palette Data (A4R4G4B4 format)
                                                            ; Note: This is the color data for an
                                                            ;       individual palette entry. Write to 
                                                            ;       DSP_PAL_IDX with the index within the
                                                            ;       color palette prior to reading or
                                                            ;       writing the color data in the
                                                            ;       GFX_PAL_CLR register.
                                                            ; 
FE18                  GPU_GLYPH_IDX         equ    $FE18    ; (Byte) Text Glyph Index
                                                            ; Note: Use this register to set the
                                                            ;       index of a specific text glyph.
                                                            ;       Set this value prior to updating
                                                            ;       the glyph data (GPU_GLYPH_DATA).
                                                            ; 
FE19                  GPU_GLYPH_DATA        equ    $FE19    ; (8-Bytes) 8 rows of binary encoded glyph pixel data
                                                            ; Note: This is the pixel data for a
                                                            ;       specific text glyph. Each 8x8
                                                            ;       text glyph is composed of 8 bytes.
                                                            ;       The first byte in this array
                                                            ;       represents the top line of 8 pixels.
                                                            ;       Each array entry represents a row of 8 pixels.
                                                            ; 
FE21                  GPU_BGND_SIZE         equ    $FE21    ; (Word) Extended Graphics Buffer Size (Read Only)
                                                            ; Note: The primary extended graphics buffer
                                                            ;       always begins at $0000. This is also highest
                                                            ;       accessible memory location of the currently
                                                            ;       active background video mode.
                                                            ; 
FE23                  GPU_BLIT_ADDR         equ    $FE23    ; (Word) Graphics Memory Address Port 
                                                            ; Note: When GPU_BLIT_DATA is accessed, this register
                                                            ;       is automatically incremented to point to the  
                                                            ;       next byte to be read or written based on the 
                                                            ;       values in GPU_BLIT_PITCH and GPU_BLIT_WIDTH.
                                                            ; 
FE25                  GPU_BLIT_PITCH        equ    $FE25    ; (Word) Number of Bytes Per Display Line
                                                            ; Note: This value represents the number of displayed
                                                            ;       pixels per line.
                                                            ; 
FE27                  GPU_BLIT_WIDTH        equ    $FE27    ; (Word) Width of the Image Block in Pixels
FE29                  GPU_BLIT_DATA         equ    $FE29    ; (Byte) GPU Memory Data Port
                                                            ; 
FE2A                  GPU_DYN_HANDLE        equ    $FE2A    ; (Word) Dynamic Memory HANDLE
                                                            ; On Write: resets GPU_DYN_CUR_ADDR,
                                                            ;     GPU_DYN_END_ADDR,  and GPU_DYN_END_DIST
                                                            ; 
FE2C                  GPU_DYN_CUR_ADDR      equ    $FE2C    ; (Word) Current Dynamic Memory ADDRESS
FE2E                  GPU_TMAP_WIDTH        equ    $FE2E    ; (Word) Tilemap Width (in pixels)
FE30                  GPU_TMAP_HEIGHT       equ    $FE30    ; (Word) Tilemap Height (in pixels)
FE32                  GPU_TMAP_XPOS         equ    $FE32    ; (SInt16) Tilemap X Position (top left corner)
FE34                  GPU_TMAP_YPOS         equ    $FE34    ; (SInt16) Tilemap Y Position (top left corner)
FE36                  GPU_TMAP_CLIP_X1      equ    $FE36    ; (Word) Tilemap Clip Region X1
FE38                  GPU_TMAP_CLIP_Y1      equ    $FE38    ; (Word) Tilemap Clip Region Y1
FE3A                  GPU_TMAP_CLIP_X2      equ    $FE3A    ; (Word) Tilemap Clip Region X2
FE3C                  GPU_TMAP_CLIP_Y2      equ    $FE3C    ; (Word) Tilemap Clip Region Y2
                                                            ; 
FE3D                  GPU_END               equ    $FE3D    ; End of GPU Register Space
FE3E                  GPU_TOP               equ    $FE3E    ; Top of GPU Register Space
                      ; _______________________________________________________________________
                      
FE3E                  CSR_DEVICE            equ    $FE3E    ; START: Mouse Device Hardware Registers
FE3E                  CSR_XPOS              equ    $FE3E    ; (Word) Horizontal Mouse Cursor Coordinate
FE40                  CSR_YPOS              equ    $FE40    ; (Word) Vertical Mouse Cursor Coordinate
FE42                  CSR_XOFS              equ    $FE42    ; (Byte) Horizontal Mouse Cursor Offset
FE43                  CSR_YOFS              equ    $FE43    ; (Byte) Vertical Mouse Cursor Offset
FE44                  CSR_SCROLL            equ    $FE44    ; (char) MouseWheel Scroll: -1, 0, 1
FE45                  CSR_FLAGS             equ    $FE45    ; (Byte) Mouse Device State Flags
                                                            ;    bits 0-4: button states
                                                            ;    bits 5-6: number of clicks
                                                            ;    bits 7:   cursor enable
                                                            ; 
FE46                  CSR_BMP_INDX          equ    $FE46    ; (Byte) Mouse Cursor Bitmap Pixel Offset
FE47                  CSR_BMP_DATA          equ    $FE47    ; (Byte) Mouse Cursor Bitmap Pixel Color Data ($0-$F)
FE48                  CSR_PAL_INDX          equ    $FE48    ; (Byte) Mouse Cursor Color Palette Index (0-15)
FE49                  CSR_PAL_DATA          equ    $FE49    ; (Word) Mouse Cursor Color Palette Data A4R4G4B4
FE4A                  CSR_END               equ    $FE4A    ; End of Mouse Device Register Space
FE4B                  CSR_TOP               equ    $FE4B    ; Top of CSR Register Space
                      ; _______________________________________________________________________
                      
FE4B                  KEYBOARD_DEVICE       equ    $FE4B    ; START: Keyboard Device Hardware Registers
FE4B                  CHAR_Q_LEN            equ    $FE4B    ; (Byte) Number of Characters Waiting in Queue   (Read Only)
FE4C                  CHAR_SCAN             equ    $FE4C    ; (Byte) Read Next Character in Queue (Not Popped When Read)
FE4D                  CHAR_POP              equ    $FE4D    ; (Byte) Read Next Character in Queue     (Popped When Read)
FE4E                  XKEY_BUFFER           equ    $FE4E    ; (16 Bytes) 128 bits for XK_KEY data buffer     (Read Only)
FE5E                  EDT_BFR_CSR           equ    $FE5E    ; (Byte) Cursor Position Within Edit Buffer     (Read/Write)
FE5F                  EDT_ENABLE            equ    $FE5F    ; (Byte) Line Editor Enable Flag                (Read/Write)
FE60                  EDT_BFR_LEN           equ    $FE60    ; (Byte) Limit the Line Editor to This Length   (Read/Write)
FE60                  KEYBOARD_END          equ    $FE60    ; End of Keyboard Register Space
FE61                  KEYBOARD_TOP          equ    $FE61    ; Top of Keyboard Register Space
                      ; _______________________________________________________________________
                      
FE61                  JOYSTICK_DEVICE       equ    $FE61    ; START: Joystick/Gamepad Controller Device Hardware Registers
FE61                  JOYS_1_FLAGS          equ    $FE61    ; (Byte) Gamepad/Joystick #1 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE62                  JOYS_1_BTN            equ    $FE62    ; (Word) Gamepad Controller Button Bits:         (Read Only)
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = A
                                                            ;            0000'0000'0000'0010 = B
                                                            ;            0000'0000'0000'0100 = X
                                                            ;            0000'0000'0000'1000 = Y
                                                            ;            0000'0000'0001'0000 = L.Shoulder
                                                            ;            0000'0000'0010'0000 = R.Shoulder
                                                            ;            0000'0000'0100'0000 = Back
                                                            ;            0000'0000'1000'0000 = Start
                                                            ;            0000'0001'0000'0000 = Misc 1
                                                            ;            0000'0010'0000'0000 = Misc 2
                                                            ;            0000'0100'0000'0000 = Misc 3
                                                            ;            0000'1000'0000'0000 = Guide
                                                            ;            0001'0000'0000'0000 = DPad Up   
                                                            ;            0010'0000'0000'0000 = DPad Down 
                                                            ;            0100'0000'0000'0000 = DPad Left 
                                                            ;            1000'0000'0000'0000 = DPad Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE64                  JOYS_1_DBND           equ    $FE64    ; (Byte) PAD 1 analog deadband; default is 5   (read/write)
FE65                  JOYS_1_LTX            equ    $FE65    ; (char) PAD 1 LThumb-X position (-128 _ +127)   (realtime)
FE66                  JOYS_1_LTY            equ    $FE66    ; (char) PAD 1 LThumb-Y position (-128 _ +127)   (realtime)
FE67                  JOYS_1_RTX            equ    $FE67    ; (char) PAD 1 RThumb-X position (-128 _ +127)   (realtime)
FE68                  JOYS_1_RTY            equ    $FE68    ; (char) PAD 1 RThumb-Y position (-128 _ +127)   (realtime)
FE69                  JOYS_1_Z1             equ    $FE69    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
FE6A                  JOYS_1_Z2             equ    $FE6A    ; (char) PAD 1 left analog trigger (0 - 127)     (realtime)
                                                            ; 
FE6B                  JOYS_2_FLAGS          equ    $FE6B    ; (Byte) Gamepad/Joystick #2 Condition Flags:     (Read Only)
                                                            ;            0000'0000: Not Connected
                                                            ;            0000'1111: Controller Type
                                                            ;            0001'0000: (reserved)
                                                            ;            0010'0000: (reserved)
                                                            ;            0100'0000: Is a Gamepad
                                                            ;            1000'0000: Is a Joystick
                                                            ; 
                                                            ;        Gamepad Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Standard
                                                            ;            2:  Xbox360
                                                            ;            3:  XboxOne
                                                            ;            4:  PS3
                                                            ;            5:  PS4
                                                            ;            6:  PS5
                                                            ;            7:  Nintendo Switch Pro
                                                            ;            8:  Nintendo Switch Joycon Left
                                                            ;            9:  Nintendo Switch Joycon Right
                                                            ; 
                                                            ;        Joystick Controller Type (bits 0-3):
                                                            ;            0:  Unknown
                                                            ;            1:  Gamepad
                                                            ;            2:  Wheel
                                                            ;            3:  Arcade Stick
                                                            ;            4:  Flight Stick
                                                            ;            5:  Dance Pad
                                                            ;            6:  Guitar
                                                            ;            7:  Drum Kit
                                                            ;            8:  Arcade Pad
                                                            ;            9:  Throttle
                                                            ; 
FE6C                  JOYS_2_BTN            equ    $FE6C    ; (Word) Button Bits: Room For up to 16 Buttons  (realtime)
                                                            ;        Joystick Button Bits:
                                                            ;            0000'0000'0000'0000 = Nothing Pressed
                                                            ;            0000'0000'0000'0001 = Button 1 
                                                            ;            0000'0000'0000'0010 = Button 2 
                                                            ;            0000'0000'0000'0100 = Button 3 
                                                            ;            0000'0000'0000'1000 = Button 4 
                                                            ;            0000'0000'0001'0000 = Button 5 
                                                            ;            0000'0000'0010'0000 = Button 6 
                                                            ;            0000'0000'0100'0000 = Button 7 
                                                            ;            0000'0000'1000'0000 = Button 8 
                                                            ;            0000'0001'0000'0000 = Button 9 
                                                            ;            0000'0010'0000'0000 = Button 10
                                                            ;            0000'0100'0000'0000 = Button 11
                                                            ;            0000'1000'0000'0000 = Button 12
                                                            ;            0001'0000'0000'0000 = Hat Up   
                                                            ;            0010'0000'0000'0000 = Hat Down 
                                                            ;            0100'0000'0000'0000 = Hat Left 
                                                            ;            1000'0000'0000'0000 = Hat Right
                                                            ;            1111'1111'1111'1111 = Not Connected
                                                            ; 
FE6E                  JOYS_2_DBND           equ    $FE6E    ; (Byte) PAD 2 analog deadband; default is 5   (read/write)
FE6F                  JOYS_2_LTX            equ    $FE6F    ; (char) PAD 2 LThumb-X position (-128 _ +127)   (realtime)
FE70                  JOYS_2_LTY            equ    $FE70    ; (char) PAD 2 LThumb-Y position (-128 _ +127)   (realtime)
FE71                  JOYS_2_RTX            equ    $FE71    ; (char) PAD 2 RThumb-X position (-128 _ +127)   (realtime)
FE72                  JOYS_2_RTY            equ    $FE72    ; (char) PAD 2 RThumb-Y position (-128 _ +127)   (realtime)
FE73                  JOYS_2_Z1             equ    $FE73    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE74                  JOYS_2_Z2             equ    $FE74    ; (char) PAD 2 left analog trigger (0 - 127)     (realtime)
FE74                  JOYS_END              equ    $FE74    ; End of Joystick/Gamepad Device Register Space
FE75                  JOYS_TOP              equ    $FE75    ; Top of Joystick/Gamepad Device Register Space
                      ; _______________________________________________________________________
                      
FE75                  FIO_DEVICE            equ    $FE75    ; START: File I/O Device Hardware Registers
FE75                  FIO_ERROR             equ    $FE75    ; (Byte) FILE_ERROR enumeration result (FE_<error>)
                                                            ; 
0000                  FE_BEGIN              equ    $0000    ;   Begin FILE_ERROR enumeration 
0000                  FE_NOERROR            equ    $0000    ;      no error, condition normal
0001                  FE_NOTFOUND           equ    $0001    ;      file or folder not found  
0002                  FE_NOTOPEN            equ    $0002    ;      file not open             
0003                  FE_EOF                equ    $0003    ;      end of file               
0004                  FE_OVERRUN            equ    $0004    ;      buffer overrun            
0005                  FE_WRONGTYPE          equ    $0005    ;      wrong file type           
0006                  FE_BAD_CMD            equ    $0006    ;      invalid command           
0007                  FE_BADSTREAM          equ    $0007    ;      invalid file stream       
0007                  FE_NOT_EMPTY          equ    $0007    ;      directory not empty       
0007                  FE_FILE_EXISTS        equ    $0007    ;      file already exists       
0007                  FE_INVALID_NAME       equ    $0007    ;      invalid file name         
0007                  FE_LAST               equ    $0007    ;   End of FILE_ERROR enumeration
                                                            ; 
FE76                  FIO_COMMAND           equ    $FE76    ; (Byte) Execute a File Command (FC_<cmd>)
                                                            ; 
0000                  FC_BEGIN              equ    $0000    ;   Begin FIO_COMMAND enumeration           
0000                  FC_RESET              equ    $0000    ;     Reset                                 
0001                  FC_SHUTDOWN           equ    $0001    ;     SYSTEM: Shutdown                      
0002                  FC_COMPDATE           equ    $0002    ;     SYSTEM: Load Compilation Date         
0003                  FC_FILEEXISTS         equ    $0003    ;     Does File Exist (return in FIO_IODATA)
0004                  FC_OPENREAD           equ    $0004    ;     Open Binary File For Reading          
0005                  FC_OPENWRITE          equ    $0005    ;     Open Binary File For Writing          
0006                  FC_OPENAPPEND         equ    $0006    ;     Open Binary File For Appending        
0007                  FC_CLOSEFILE          equ    $0007    ;     Close File                            
0008                  FC_READBYTE           equ    $0008    ;     Read Byte (into FIO_IOBYTE)           
0009                  FC_WRITEBYTE          equ    $0009    ;     Write Byte (from FIO_IOBYTE)          
000A                  FC_LOADHEX            equ    $000A    ;     Load Hex Format File                  
000B                  FC_GETLENGTH          equ    $000B    ;     Get File Length (into FIO_IOWORD)     
000C                  FC_LISTDIR            equ    $000C    ;     List Directory                        
000D                  FC_MAKEDIR            equ    $000D    ;     Make Directory                        
000E                  FC_CHANGEDIR          equ    $000E    ;     Change Directory                      
000F                  FC_GETPATH            equ    $000F    ;     Fetch Current Path                    
0010                  FC_REN_DIR            equ    $0010    ;     Rename Directory                      
0011                  FC_DEL_DIR            equ    $0011    ;     Delete Directory                      
0012                  FC_DEL_FILE           equ    $0012    ;     Delete File                           
0013                  FC_REN_FILE           equ    $0013    ;     Rename File                           
0014                  FC_COPY_FILE          equ    $0014    ;     Copy File                             
0015                  FC_SEEK_START         equ    $0015    ;     Seek Start                            
0016                  FC_SEEK_END           equ    $0016    ;     Seek End                              
0017                  FC_SET_SEEK           equ    $0017    ;     Set Seek Position (from FIO_IOWORD)   
0018                  FC_GET_SEEK           equ    $0018    ;     Get Seek Position (into FIO_IOWORD)   
0018                  FC_LAST               equ    $0018    ;   End FIO_COMMAND enumeration             
                                                            ; 
FE77                  FIO_HANDLE            equ    $FE77    ; (Byte) Current File Stream HANDLE (0=NONE)
FE78                  FIO_SEEKPOS           equ    $FE78    ; (DWord) File Seek Position
FE7C                  FIO_IODATA            equ    $FE7C    ; (Byte) Input / Output Data
                                                            ; 
FE7D                  FIO_PATH_LEN          equ    $FE7D    ; (Byte) Length of the Primary Filepath        (Read Only)
FE7E                  FIO_PATH_POS          equ    $FE7E    ; (Byte) Character Position Within the Primary Filepath
FE7F                  FIO_PATH_DATA         equ    $FE7F    ; (Byte) Data at the Character Position of the Primary Path
                                                            ; 
FE80                  FIO_ALT_PATH_LEN      equ    $FE80    ; (Byte) Length of the alternate Filepath        (Read Only)
FE81                  FIO_ALT_PATH_POS      equ    $FE81    ; (Byte) Character Position Within the Alternate Filepath
FE82                  FIO_ALT_PATH_DATA     equ    $FE82    ; (Byte) Data at the Character Position of the Alternate Path
                                                            ; 
FE83                  FIO_DIR_DATA          equ    $FE83    ; (Byte) A Series of Null-Terminated Filenames
                                                            ;   NOTE: Current read-position is reset to the beginning
                                                            ;     following a List Directory command. The read-position
                                                            ;     is automatically advanced on read from this register.
                                                            ;     Each filename is $0A-terminated. The list itself is
                                                            ;     null-terminated.
                                                            ; 
FE83                  FIO_END               equ    $FE83    ; End of FIO Device Register Space
FE84                  FIO_TOP               equ    $FE84    ; Top of FIO Device Register Space
                      ; _______________________________________________________________________
                      
FE84                  MATH_DEVICE           equ    $FE84    ; START: Math Co-Processor Device Hardware Registers
FE84                  MATH_ACA_POS          equ    $FE84    ; (Byte) Character Position Within the ACA Float String
FE85                  MATH_ACA_DATA         equ    $FE85    ; (Byte) ACA Float String Character Port
FE86                  MATH_ACA_RAW          equ    $FE86    ; (4-Bytes) ACA Raw Float Data
FE8A                  MATH_ACA_INT          equ    $FE8A    ; (4-Bytes) ACA Integer Data
                                                            ; 
FE8E                  MATH_ACB_POS          equ    $FE8E    ; (Byte) Character Position Within the ACB Float String
FE8F                  MATH_ACB_DATA         equ    $FE8F    ; (Byte) ACB Float String Character Port
FE90                  MATH_ACB_RAW          equ    $FE90    ; (4-Bytes) ACB Raw Float Data
FE94                  MATH_ACB_INT          equ    $FE94    ; (4-Bytes) ACB Integer Data
                                                            ; 
FE98                  MATH_ACR_POS          equ    $FE98    ; (Byte) Character Position Within the ACR Float String
FE99                  MATH_ACR_DATA         equ    $FE99    ; (Byte) ACR Float String Character Port
FE9A                  MATH_ACR_RAW          equ    $FE9A    ; (4-Bytes) ACR Raw Float Data
FE9E                  MATH_ACR_INT          equ    $FE9E    ; (4-Bytes) ACR Integer Data
                                                            ; 
FEA2                  MATH_OPERATION        equ    $FEA2    ; (Byte) ACA Float String Character Port   (On Write)
0000                  MOP_BEGIN             equ    $0000    ;   BEGIN Math Operation Enumeration:
0000                  MOP_RANDOM            equ    $0000    ;     ACA, ACB, and ACR are set to randomized values
0001                  MOP_RND_SEED          equ    $0001    ;     MATH_ACA_INT seeds the pseudo-random number generator
0002                  MOP_IS_EQUAL          equ    $0002    ;     (bool)ACR = (ACA == ACB)
0003                  MOP_IS_NOT_EQUAL      equ    $0003    ;     (bool)ACR = (ACA != ACB)
0004                  MOP_IS_LESS           equ    $0004    ;     (bool)ACR = std::isless(ACA, ACB)
0005                  MOP_IS_GREATER        equ    $0005    ;     (bool)ACR = std::isgreater(ACA, ACB)
0006                  MOP_IS_LTE            equ    $0006    ;     (bool)ACR = std::islessequal(ACA, ACB)
0007                  MOP_IS_GTE            equ    $0007    ;     (bool)ACR = std::islessgreater(ACA, ACB)
0008                  MOP_IS_FINITE         equ    $0008    ;     (bool)ACR = std::isfinite(ACA)
0009                  MOP_IS_INF            equ    $0009    ;     (bool)ACR = std::isinf(ACA)
000A                  MOP_IS_NAN            equ    $000A    ;     (bool)ACR = std::isnan(ACA)
000B                  MOP_IS_NORMAL         equ    $000B    ;     (bool)ACR = std::isnormal(ACA)
000C                  MOP_SIGNBIT           equ    $000C    ;     (bool)ACR = std::signbit(ACA)
000D                  MOP_SUBTRACT          equ    $000D    ;     ACR = ACA - ACB
000E                  MOP_ADD               equ    $000E    ;     ACR = ACA + ACB
000F                  MOP_MULTIPLY          equ    $000F    ;     ACR = ACA * ACB
0010                  MOP_DIVIDE            equ    $0010    ;     ACR = ACA / ACB
0011                  MOP_FMOD              equ    $0011    ;     ACR = std::fmod(ACA, ACB)
0012                  MOP_REMAINDER         equ    $0012    ;     ACR = std::remainder(ACA, ACB)
0013                  MOP_FMAX              equ    $0013    ;     ACR = std::fmax(ACA, ACB)
0014                  MOP_FMIN              equ    $0014    ;     ACR = std::fmin(ACA, ACB)
0015                  MOP_FDIM              equ    $0015    ;     ACR = std::fdim(ACA, ACB)
0016                  MOP_EXP               equ    $0016    ;     ACR = std::exp(ACA)
0017                  MOP_EXP2              equ    $0017    ;     ACR = std::exp2(ACA)
0018                  MOP_EXPM1             equ    $0018    ;     ACR = std::expm1(ACA)
0019                  MOP_LOG               equ    $0019    ;     ACR = std::log(ACA)
001A                  MOP_LOG10             equ    $001A    ;     ACR = std::log10(ACA)
001B                  MOP_LOG2              equ    $001B    ;     ACR = std::log2(ACA)
001C                  MOP_LOG1P             equ    $001C    ;     ACR = std::log1p(ACA)
001D                  MOP_SQRT              equ    $001D    ;     ACR = std::sqrt(ACA)
001E                  MOP_CBRT              equ    $001E    ;     ACR = std::cbrt(ACA)
001F                  MOP_HYPOT             equ    $001F    ;     ACR = std::hypot(ACA, ACB)
0020                  MOP_POW               equ    $0020    ;     ACR = std::pow(ACA, ACB)
0021                  MOP_SIN               equ    $0021    ;     ACR = std::sin(ACA)
0022                  MOP_COS               equ    $0022    ;     ACR = std::cos(ACA)
0023                  MOP_TAN               equ    $0023    ;     ACR = std::tan(ACA)
0024                  MOP_ASIN              equ    $0024    ;     ACR = std::asin(ACA)
0025                  MOP_ACOS              equ    $0025    ;     ACR = std::acos(ACA)
0026                  MOP_ATAN              equ    $0026    ;     ACR = std::atan(ACA)
0027                  MOP_ATAN2             equ    $0027    ;     ACR = std::atan2(ACA, ACB)
0028                  MOP_SINH              equ    $0028    ;     ACR = std::sinh(ACA)
0029                  MOP_COSH              equ    $0029    ;     ACR = std::cosh(ACA)
002A                  MOP_ASINH             equ    $002A    ;     ACR = std::asinh(ACA)
002B                  MOP_ACOSH             equ    $002B    ;     ACR = std::acosh(ACA)
002C                  MOP_ATANH             equ    $002C    ;     ACR = std::atanh(ACA)
002D                  MOP_ERF               equ    $002D    ;     ACR = std::erf(ACA)
002E                  MOP_ERFC              equ    $002E    ;     ACR = std::erfc(ACA)
002F                  MOP_LGAMMA            equ    $002F    ;     ACR = std::lgamma(ACA)
0030                  MOP_TGAMMA            equ    $0030    ;     ACR = std::tgamma(ACA)
0031                  MOP_CEIL              equ    $0031    ;     ACR = std::ceil(ACA)
0032                  MOP_FLOOR             equ    $0032    ;     ACR = std::floor(ACA)
0033                  MOP_TRUNC             equ    $0033    ;     ACR = std::trunc(ACA)
0034                  MOP_ROUND             equ    $0034    ;     ACR = std::round(ACA)
0035                  MOP_LROUND            equ    $0035    ;     ACR = std::lround(ACA)
0036                  MOP_NEARBYINT         equ    $0036    ;     ACR = std::nearbyint(ACA)
0037                  MOP_ILOGB             equ    $0037    ;     ACR = std::ilogb(ACA)
0038                  MOP_LOGB              equ    $0038    ;     ACR = std::logb(ACA)
0039                  MOP_NEXTAFTER         equ    $0039    ;     ACR = std::nextafter(ACA, ACB)
003A                  MOP_COPYSIGN          equ    $003A    ;     ACR = std::copysign(ACA, ACB)
003B                  MOP_LASTOP            equ    $003B    ;   END Math Operation Enumeration
FEA2                  MATH_END              equ    $FEA2    ; End of Math Co-Processor Register Space
FEA3                  MATH_TOP              equ    $FEA3    ; Top of Math Co-Processor Register Space
                      ; _______________________________________________________________________
                      
FEA3                  MMU_DEVICE            equ    $FEA3    ; START: Memory Management Unit Hardware Registers
FEA3                  MMU_PAGE_1_SELECT     equ    $FEA3    ; (Word) Page Select for 8K Memory Bank 1
FEA5                  MMU_PAGE_2_SELECT     equ    $FEA5    ; (Word) Page Select for 8K Memory Bank 2
FEA7                  MMU_BLOCKS_FREE       equ    $FEA7    ; (Word) Number of 32-Byte Blocks Available for Allocation (Read Only)
FEA9                  MMU_BLOCKS_ALLOCATED  equ    $FEA9    ; (Word) Number of 32-Byte Blocks Currently Allocated  (Read Only)
FEAB                  MMU_BLOCKS_FRAGGED    equ    $FEAB    ; (Word) Number of 32-Byte Blocks Currently Fragmented  (Read Only)
FEAD                  MMU_ARG_1             equ    $FEAD    ; (Word) Argument 1 for MMU Command
FEAD                  MMU_ARG_1_MSB         equ    $FEAD    ; (Byte) Argument 1 Most Significant Byte for MMU Command
FEAE                  MMU_ARG_1_LSB         equ    $FEAE    ; (Byte) Argument 1 Least Significant Byte for MMU Command
FEAF                  MMU_ARG_2             equ    $FEAF    ; (Word) Argument 2 for MMU Command
FEAF                  MMU_ARG_2_MSB         equ    $FEAF    ; (Byte) Argument 2 Most Significant Byte for MMU Command
FEB0                  MMU_ARG_2_LSB         equ    $FEB0    ; (Byte) Argument 2 Least Significant Byte for MMU Command
                                                            ; 
FEB1                  MMU_COMMAND           equ    $FEB1    ; (Byte) Memory Management Unit Command:
0000                  MMU_CMD_NOP           equ    $0000    ;    $00 = No Operation / Error
0001                  MMU_CMD_PG_ALLOC      equ    $0001    ;    $01 = Page Allocate (8K Bytes)
0002                  MMU_CMD_PG_FREE       equ    $0002    ;    $02 = Page Deallocate (8K Bytes)
0003                  MMU_CMD_ALLOC         equ    $0003    ;    $03 = Allocate Chain (< 8K Bytes)
0004                  MMU_CMD_LOAD_ROOT     equ    $0004    ;    $04 = Load Root Node
0005                  MMU_CMD_LOAD_NEXT     equ    $0005    ;    $05 = Load Next Node
0006                  MMU_CMD_LOAD_PREV     equ    $0006    ;    $06 = Load Prev Node
0007                  MMU_CMD_LOAD_LAST     equ    $0007    ;    $07 = Load Last Node
0008                  MMU_CMD_DEL_NODE      equ    $0008    ;    $08 = Remove Current Node (and Adjust Links)
0009                  MMU_CMD_INS_BEFORE    equ    $0009    ;    $09 = Insert Node Before (and activate)
000A                  MMU_CMD_INS_AFTER     equ    $000A    ;    $0A = Insert Node After (and activate)
000B                  MMU_CMD_PUSH_BACK     equ    $000B    ;    $0B = Push Back (and activate)
000C                  MMU_CMD_PUSH_FRONT    equ    $000C    ;    $0C = Push Front (and activate)
000D                  MMU_CMD_POP_BACK      equ    $000D    ;    $0D = Pop Back (and activate)
000E                  MMU_CMD_POP_FRONT     equ    $000E    ;    $0E = Pop Front (and activate)
000F                  MMU_CMD_LOCK_NODE     equ    $000F    ;    $0F = Lock Node
0010                  MMU_CMD_UNLOCK_NODE   equ    $0010    ;    $10 = Unlock Node
0011                  MMU_CMD_FREE          equ    $0011    ;    $11 = Deallocate Chain (< 8K Bytes)
0012                  MMU_CMD_DEFRAG        equ    $0012    ;    $12 = Defragment / Collect Garbage
0013                  MMU_CMD_RESET         equ    $0013    ;    $13 = Reset Memory Management Unit
0014                  MMU_CMD_SIZE          equ    $0014    ;    $14 = Total Number of MMU Commands
                                                            ; 
FEB2                  MMU_ERROR             equ    $FEB2    ; (Byte) Memory Management Unit Error Code:     (Read Only)
0000                  MMU_ERR_NONE          equ    $0000    ;    $00 = No Error
0001                  MMU_ERR_ALLOC         equ    $0001    ;    $01 = Failed to Allocate Memory
0002                  MMU_ERR_FREE          equ    $0002    ;    $02 = Failed to Deallocate Memory
0003                  MMU_ERR_PG_FREE       equ    $0003    ;    $03 = Error Deallocating Page
0004                  MMU_ERR_INVALID       equ    $0004    ;    $04 = Invalid Command
0005                  MMU_ERR_HANDLE        equ    $0005    ;    $05 = Invalid Handle
0006                  MMU_ERR_NODE          equ    $0006    ;    $06 = Invalid Node
0007                  MMU_ERR_RAW_INDEX     equ    $0007    ;    $07 = Invalid Raw Index
0008                  MMU_ERR_SIZE          equ    $0008    ;    $08 = Total Number of MMU Errors
                                                            ; 
FEB3                  MMU_META_HANDLE       equ    $FEB3    ; (Word) Handle for the current allocation chain
                                                            ; 
FEB5                  MMU_META_STATUS       equ    $FEB5    ; (Byte) Status Flags:
0001                  MMU_STFLG_ALLOC       equ    $0001    ;    0000'0001: Is Allocated: 0 = Free, 1 = Allocated
0002                  MMU_STFLG_PAGED       equ    $0002    ;    0000'0010: Paged Memory: 0 = No,   1 = Yes
0004                  MMU_STFLG_READONLY    equ    $0004    ;    0000'0100: Memory Type:  0 = RAM,  1 = ROM
0008                  MMU_STFLG_FRAGD       equ    $0008    ;    0000'1000: Fragmented:   0 = No,   1 = Yes
0010                  MMU_STFLG_LOCKED      equ    $0010    ;    0001'0000: Locked:       0 = No,   1 = Yes
0020                  MMU_STFLG_RES_1       equ    $0020    ;    0010'0000:   (reserved)
0040                  MMU_STFLG_RES_2       equ    $0040    ;    0100'0000:   (reserved)
0080                  MMU_STFLG_ERROR       equ    $0080    ;    1000'0000: Error:        0 = No,   1 = Yes
                                                            ; 
FEB6                  MMU_META_DATA         equ    $FEB6    ; (32-Bytes) Data Window for the Current Allocation
FED6                  MMU_META_ROOT         equ    $FED6    ; (Word) Root node of the current allocation       (Read Only)
FED8                  MMU_META_PREV         equ    $FED8    ; (Word) Previous node of the current allocation   (Read Only)
FEDA                  MMU_META_NEXT         equ    $FEDA    ; (Word) Next node of the current allocation       (Read Only)
FEDC                  MMU_RAW_INDEX         equ    $FEDC    ; (Word) Raw Index of the current memory node  (Node Window)
                                                            ; 
FEDD                  MMU_END               equ    $FEDD    ; End of Banked Memory Register Space
FEDE                  MMU_TOP               equ    $FEDE    ; Top of Banked Memory Register Space
                      ; _______________________________________________________________________
                      
FEDE                  HDW_RESERVED_DEVICE   equ    $FEDE    ; START: Reserved Register Space
FFF0                  HDW_REG_END           equ    $FFF0    ; 274 bytes reserved for future use.
                      ; _______________________________________________________________________
                      
FFF0                  ROM_VECTS_DEVICE      equ    $FFF0    ; START: Hardware Interrupt Vectors
FFF0                  HARD_EXEC             equ    $FFF0    ; EXEC Hardware Interrupt Vector
FFF2                  HARD_SWI3             equ    $FFF2    ; SWI3 Hardware Interrupt Vector
FFF4                  HARD_SWI2             equ    $FFF4    ; SWI2 Hardware Interrupt Vector
FFF6                  HARD_FIRQ             equ    $FFF6    ; FIRQ Hardware Interrupt Vector
FFF8                  HARD_IRQ              equ    $FFF8    ; IRQ Hardware Interrupt Vector
FFFA                  HARD_SWI              equ    $FFFA    ; SWI / SYS Hardware Interrupt Vector
FFFC                  HARD_NMI              equ    $FFFC    ; NMI Hardware Interrupt Vector
FFFE                  HARD_RESET            equ    $FFFE    ; RESET Hardware Interrupt Vector
                      
                      
                      ; END of memory_map.asm definitions
                      
                      
                      
                      ; sys macro expands to SWI2 with a following command byte
                      sys                 macro
                                          swi2
                                          fcb \1
                                          endm
                      
                      
                      ; *****************************************************************************
                      ; * SYSTEM SOFTWARE VECTORS                                                   *
                      ; *****************************************************************************
0000                  VEC_EXEC            equ     $0000       ; User defined EXEC vector
0002                  VEC_SWI3            equ     $0002       ; SWI3 Software Interrupt Vector
0004                  VEC_SWI2            equ     $0004       ; SWI2 Software Interrupt Vector
0006                  VEC_FIRQ            equ     $0006       ; FIRQ Software Interrupt Vector
0008                  VEC_IRQ             equ     $0008       ; IRQ Software Interrupt Vector
000A                  VEC_SWI             equ     $000A       ; SWI / SYS Software Interrupt Vector
000C                  VEC_NMI             equ     $000C       ; NMI Software Interrupt Vector
000E                  VEC_RESET           equ     $000E       ; RESET Software Interrupt Vector
                      
                      ; *****************************************************************************
                      ; * KERNAL ROUTINE SOFTWARE VECTORS                                           *
                      ; *****************************************************************************
0010                  VEC_CLS             equ     $0010       ; CLS function Software Vector
0012                  VEC_CHROUT          equ     $0012       ; Character Out Software Vector
0014                  VEC_NEWLINE         equ     $0014       ; Kernel Newline Software Vector
0016                  VEC_LINEOUT         equ     $0016       ; String to Console Software Vector
0018                  VEC_CSRPOS          equ     $0018       ; Cursor Position Software Vector
001A                  VEC_SCROLL          equ     $001A       ; Scroll Text Screen Software Vector
001C                  VEC_LINEEDIT        equ     $001C       ; Console Line Editor Software Vector
001E                  VEC_GETKEY          equ     $001E       ; Wait for Key Press Software Vector
0020                  VEC_GETHEX          equ     $0020       ; Wait for Hex Character Software Vector
0022                  VEC_GETNUM          equ     $0022       ; Wait for Numeric Character Vector
0024                  VEC_CMPSTR          equ     $0024       ; Compare two strings of arbitrary lengths Vector
0026                  VEC_CMD_PROC        equ     $0026       ; Parse the command entered by the user Vector
0028                  VEC_TBLSEARCH       equ     $0028       ; Table Search and Return index Vector
002A                  VEC_CPY_DWORD       equ     $002A       ; Copy 32-bits from addr X addr Y Vector
002C                  VEC_D_TO_RAWA       equ     $002C       ; Write the D register to RAWA  Vector
002E                  VEC_D_TO_RAWB       equ     $002E       ; Write the D register to RAWB Vector
0030                  VEC_D_TO_RAWR       equ     $0030       ; Write the D register to RAWR Vector
0032                  VEC_D_TO_INTA       equ     $0032       ; Write the D register to INTA Vector
0034                  VEC_D_TO_INTB       equ     $0034       ; Write the D register to INTB Vector
0036                  VEC_D_TO_INTR       equ     $0036       ; Write the D register to INTR Vector
0038                  VEC_RAWA_TO_D       equ     $0038       ; Read the RAWA float into D Vector
003A                  VEC_RAWB_TO_D       equ     $003A       ; Read the RAWB float into D Vector
003C                  VEC_RAWR_TO_D       equ     $003C       ; Read the RAWD float into D Vector
003E                  VEC_INTA_TO_D       equ     $003E       ; Read the INTA integer into D Vector
0040                  VEC_INTB_TO_D       equ     $0040       ; Read the INTB integer into D Vector
0042                  VEC_INTR_TO_D       equ     $0042       ; Read the INTR integer into D Vector
0044                  VEC_8BIT_MATH       equ     $0044       ; 8-bit integer math Vector
0046                  VEC_DSP_ACA         equ     $0046       ; Send to console the float in ACA Vector
0048                  VEC_DSP_ACB         equ     $0048       ; Send to console the float in ACB Vector
004A                  VEC_DSP_ACR         equ     $004A       ; Send to console the float in ACA Vector
004C                  VEC_DSP_INTA        equ     $004C       ; Send to console the integer in ACA Vector
004E                  VEC_DSP_INTB        equ     $004E       ; Send to console the integer in ACB Vector
0050                  VEC_DSP_INTR        equ     $0050       ; Send to console the integer in ACR Vector
0052                  VEC_WRITE_ACA       equ     $0052       ; Write RAW float X points to into ACA Vector
0054                  VEC_WRITE_ACB       equ     $0054       ; Write RAW float X points to into ACB Vector
0056                  VEC_WRITE_ACR       equ     $0056       ; Write RAW float X points to into ACR Vector
0058                  VEC_ARG_TO_A        equ     $0058       ; Convert numeric string to binary in A Vector
                      
                      
                      ; *****************************************************************************
                      ; * RESERVED ZERO PAGE KERNAL VARIABLES                                       *
                      ; *****************************************************************************
005A                  _CURSOR_COL         equ     $005A       ; (Byte) current cursor horizontal position
005B                  _CURSOR_ROW         equ     $005B       ; (Byte) current cursor vertical position
005C                  _ATTRIB             equ     $005C       ; (Byte) current character display attribute
005D                  _ANCHOR_COL         equ     $005D       ; (Byte) line edit anchor column
005E                  _ANCHOR_ROW         equ     $005E       ; (Byte) line edit anchor row
005F                  _LOCAL_0            equ     $005F       ; (Byte) used locally for some kernel calls
0060                  _LOCAL_1            equ     $0060       ; (Byte) used locally for some kernel calls
0061                  _LOCAL_2            equ     $0061       ; (Byte) used locally for some kernel calls
0062                  _LOCAL_3            equ     $0062       ; (Byte) used locally for some kernel calls
                      
0063                  ZERO_PAGE_USER      equ     _LOCAL_3+1  ; start of user appropriate zero-page memory
                      
                      
                      ; *******************************************************************************
                      ; * SYS CALL CONSTANTS                                                          *
                      ; *     usage:                                                                  *
                      ; *             sys     CALL_CLS        ; clear the screen                      *
                      ; *             ...                                                             *
                      ; *                                                                             *
                      ; *             lda     #'Z'            ; Load the text glyph 'Z' into A        *
                      ; *             sys     CALL_CHROUT     ; Display the 'Z' on the text screen    *
                      ; *             ...                                                             *
                      ; *                                                                             *
                      ; *                                                                             *
                      ; *             sys     CALL_LINEOUT    ; Display Null-terminated string        *
                      ; *                                     ; pointed to by X at the current        *
                      ; *                                     ; cursor location:                      *
                      ; *                                             _CURSOR_COL x _CURSOR_ROW       *
                      ; *             ...                                                             *
                      ; *******************************************************************************
0000                  CALL_GARBAGE        equ     $00     ; $00 random garbage
0001                  CALL_CLS            equ     $01         ; $01 CLS
0002                  CALL_CHROUT         equ     $02     ; $02 CHROUT
0003                  CALL_NEWLINE        equ     $03         ; $03 NEWLINE
0004                  CALL_TAB            equ     $04         ; $04 TAB
0005                  CALL_LINEOUT        equ     $05         ; $05 LINEOUT
0006                  CALL_CSRPOS         equ     $06         ; $06 CSRPOS
0007                  CALL_SCROLL         equ     $07         ; $07 SCROLL
0008                  CALL_LINEEDIT       equ     $08     ; $08 LINEEDIT
0009                  CALL_GETKEY         equ     $09     ; $09 GETKEY
000A                  CALL_GETHEX         equ     $0A     ; $0A GETHEX
000B                  CALL_GETNUM         equ     $0B     ; $0B GETNUM
000C                  CALL_CMPSTR         equ     $0C     ; $0C CMPSTR
000D                  CALL_CMD_PROC       equ     $0D     ; $0D CMD_PROC
000E                  CALL_TBLSEARCH      equ     $0E     ; $0E TBLSEARCH
000F                  CALL_CPY_DWORD      equ     $0F     ; $0F CPY_DWORD
0010                  CALL_D_TO_RAWA      equ     $10     ; $10 D_TO_RAWA
0011                  CALL_D_TO_RAWB      equ     $11     ; $11 D_TO_RAWB
0012                  CALL_D_TO_RAWR      equ     $12     ; $12 D_TO_RAWR
0013                  CALL_D_TO_INTA      equ     $13     ; $13 D_TO_INTA
0014                  CALL_D_TO_INTB      equ     $14     ; $14 D_TO_INTB
0015                  CALL_D_TO_INTR      equ     $15     ; $15 D_TO_INTR
0016                  CALL_RAWA_TO_D      equ     $16     ; $16 RAWA_TO_D
0017                  CALL_RAWB_TO_D      equ     $17     ; $17 RAWB_TO_D
0018                  CALL_RAWR_TO_D      equ     $18     ; $18 RAWR_TO_D
0019                  CALL_INTA_TO_D      equ     $19     ; $19 INTA_TO_D
001A                  CALL_INTB_TO_D      equ     $1A     ; $1A INTB_TO_D
001B                  CALL_INTR_TO_D      equ     $1B     ; $1B INTR_TO_D
001C                  CALL_8BIT_MATH      equ     $1C     ; $1C 8BIT_MATH
001D                  CALL_DSP_ACA        equ     $1D     ; $1D DSP_ACA
001E                  CALL_DSP_ACB        equ     $1E     ; $1E DSP_ACB
001F                  CALL_DSP_ACR        equ     $1F     ; $1F DSP_ACR
0020                  CALL_DSP_INTA       equ     $20     ; $20 DSP_INTA
0021                  CALL_DSP_INTB       equ     $21     ; $21 DSP_INTB
0022                  CALL_DSP_INTR       equ     $22     ; $22 DSP_INTR
0023                  CALL_WRITE_ACA      equ     $23     ; $23 WRITE_ACA
0024                  CALL_WRITE_ACB      equ     $24     ; $24 WRITE_ACB
0025                  CALL_WRITE_ACR      equ     $25     ; $25 WRITE_ACR
0026                  CALL_ARG_TO_A       equ     $26     ; $26 ARG_TO_A
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
F000                                  org     KERNEL_START
F000  7EF1E2          KRNL_START      jmp     KRNL_BEGIN
                      
                      ; Notes: 
                      ;       fcc     stores raw character string with no default termination
                      ;       fcs     character string with its terminators high bit set
                      ;       fcn     character string with null termination
                      
F003  526574726F2036383039204B65726E656C20524F4D2056302E342E310A00 KRNL_PROMPT0    fcn     "Retro 6809 Kernel ROM V0.4.1\n"
F021  456D756C61746F7220636F6D70696C65642000 KRNL_PROMPT1    fcn     "Emulator compiled "
F034  474E552047656E6572616C205075626C6963204C697363656E7365202847504C205633290A00 KRNL_PROMPT2    fcn     "GNU General Public Liscense (GPL V3)\n"
F05A  436F707972696768742028432920323032342D32303235204279204A6179204661726965730A0A00 KRNL_PROMPT3    fcn     "Copyright (C) 2024-2025 By Jay Faries\n\n"  
F082  52656164790A00  READY_PROMPT    fcn     "Ready\n"
                      
                      
                      ; *****************************************************************************
                      ; * MAIN KERNEL COMMAND SUBROUTINES (Prototypes)                              *
                      ; *****************************************************************************
                      ;       do_cls          ; #0            ; Clear Screen (0-255) or ($00-$FF)
                      ;       do_color        ; #1            ; Change Color (0-255) or ($00-$FF)
                      ;       do_load         ; #2            ; Load an Intel Hex Formatted File
                      ;       do_exec         ; #3            ; Execute a Loaded Program
                      ;       do_reset        ; #4            ; Reset the System
                      ;       do_dir          ; #5            ; Display Files and Folders in a Folder
                      ;       do_cd           ; #6            ; Change the Current Directory
                      ;       do_pwd          ; #7            ; Print Working Directory
                      ;       do_chdir        ; #8            ; Alias of CD
                      ;       do_exit         ; #9            ; Exit the Emulator
                      ;       do_quit         ; #10           ; Same as "do_exit"
                      ;       do_mode         ; #11           ; Display Mode (0-31) or ($00-$1F)
                      ;       do_debug        ; #12           ; Enter or Exit the Debugger
                      ;       do_help         ; #13           ; Display usage help
                      
F089                  KRNL_CMD_TABLE  
F089  636C7300                        fcn     "cls"           ; #0
F08D  636F6C6F7200                    fcn     "color"         ; #1
F093  6C6F616400                      fcn     "load"          ; #2
F098  6578656300                      fcn     "exec"          ; #3
F09D  726573657400                    fcn     "reset"         ; #4
F0A3  64697200                        fcn     "dir"           ; #5
F0A7  636400                          fcn     "cd"            ; #6
F0AA  636864697200                    fcn     "chdir"         ; #7
F0B0  70776400                        fcn     "pwd"           ; #8
F0B4  6578697400                      fcn     "exit"          ; #9
F0B9  7175697400                      fcn     "quit"          ; #10
F0BE  6D6F646500                      fcn     "mode"          ; #11
F0C3  646562756700                    fcn     "debug"         ; #12
F0C9  68656C7000                      fcn     "help"          ; #13
F0CE  FF                              fcb     $FF             ; $FF = end of list
                                      ; ...
                      
F0CF                  KRNL_CMD_VECTS  
F0CF  F2B9                            fdb     do_cls          ; #0
F0D1  F2D5                            fdb     do_color        ; #1
F0D3  F32C                            fdb     do_load         ; #2
F0D5  F367                            fdb     do_exec         ; #3
F0D7  F36C                            fdb     do_reset        ; #4
F0D9  F372                            fdb     do_dir          ; #5
F0DB  F384                            fdb     do_cd           ; #6
F0DD  F384                            fdb     do_chdir        ; #7
F0DF  F38E                            fdb     do_pwd          ; #8
F0E1  F3A1                            fdb     do_exit         ; #9
F0E3  F3A2                            fdb     do_quit         ; #10
F0E5  F3A8                            fdb     do_mode         ; #11
F0E7  F3DA                            fdb     do_debug        ; #12
F0E9  F40B                            fdb     do_help         ; #13
                                      ; ...
F0EB  4552524F523A20436F6D6D616E64204E6F7420466F756E640A00 KRNL_ERR_NFND   fcn     "ERROR: Command Not Found\n"
F105  2076616C696420636F6D6D616E6473206172653A0A krnl_help_str   fcc     " valid commands are:\n"
F11A  2020636C732C202020636F6C6F722C206C6F61642C0A                 fcc     "  cls,   color, load,\n"
F130  2020657865632C202072657365742C206469722C0A                 fcc     "  exec,  reset, dir,\n"
F145  202063642C2020202063686469722C207077642C0A                 fcc     "  cd,    chdir, pwd,\n"
F15A  2020657869742C2020717569742C20206D6F64650A                 fcc     "  exit,  quit,  mode\n"
F16F  202064656275672C20616E642068656C700A00                 fcn     "  debug, and help\n"
                      
                      * krnl_help_str fcc     "cls:   Clear Screen (0-255) or ($00-$FF)\n"
                      *               fcc     "color: Change Color (0-255) or ($00-$FF)\n"
                      *               fcc     "load:  Load an Intel Hex Formatted File\n"
                      *               fcc     "exec:  Execute a Loaded Program\n"
                      *               fcc     "reset: Reset the System\n"
                      *               fcc     "dir:   Display Files and Folders in a Folder\n"
                      *               fcc     "cd:    Change the Current Directory\n"
                      *               fcc     "chdir: Alias of CD\n"
                      *               fcc     "pwd:   Print Working Directory\n"
                      *               fcc     "exit:  Exit the Emulator\n"
                      *               fcc     "quit:  Same as "do_exit"\n"
                      *               fcc     "mode:  Display Mode (0-31) or ($00-$1F)\n"
                      *               fcc     "debug: Enter or Exit the Debugger\n"
                      *               fcn     "help"  Display usage help\n"
                      
                      
                      ; *****************************************************************************
                      ; * KERNAL ROUTINE SOFTWARE VECTORS                                           *
                      ; *****************************************************************************
F182                  SYSTEM_DATA_START
F182  F49B                            fdb     STUB_CLS        ; VECT_CLS      
F184  F4BE                            fdb     STUB_CHROUT     ; VECT_CHROUT   
F186  F4F7                            fdb     STUB_NEWLINE    ; VECT_NEWLINE  
F188  F533                            fdb     STUB_LINEOUT    ; VECT_LINEOUT  
F18A  F551                            fdb     STUB_CSRPOS     ; VECT_CSRPOS   
F18C  F571                            fdb     STUB_SCROLL     ; VECT_SCROLL   
F18E  F5A7                            fdb     STUB_LINEEDIT   ; VECT_LINEEDIT 
F190  F62F                            fdb     STUB_GETKEY     ; VECT_GETKEY   
F192  F648                            fdb     STUB_GETHEX     ; VECT_GETHEX   
F194  F670                            fdb     STUB_GETNUM     ; VECT_GETNUM   
F196  F688                            fdb     STUB_CMPSTR     ; VECT_CMPSTR   
F198  F6BD                            fdb     STUB_CMD_PROC   ; VECT_CMD_PROC 
F19A  F719                            fdb     STUB_TBLSEARCH  ; VECT_TBLSEARCH        
F19C  F73D                            fdb     STUB_CPY_DWORD  ; VECT_CPY_DWORD        
F19E  F751                            fdb     STUB_D_TO_RAWA  ; VECT_D_TO_RAWA        
F1A0  F766                            fdb     STUB_D_TO_RAWB  ; VECT_D_TO_RAWB        
F1A2  F77B                            fdb     STUB_D_TO_RAWR  ; VECT_D_TO_RAWR        
F1A4  F790                            fdb     STUB_D_TO_INTA  ; VECT_D_TO_INTA        
F1A6  F7A5                            fdb     STUB_D_TO_INTB  ; VECT_D_TO_INTB        
F1A8  F7BA                            fdb     STUB_D_TO_INTR  ; VECT_D_TO_INTR        
F1AA  F7CF                            fdb     STUB_RAWA_TO_D  ; VECT_RAWA_TO_D        
F1AC  F7DE                            fdb     STUB_RAWB_TO_D  ; VECT_RAWB_TO_D        
F1AE  F7ED                            fdb     STUB_RAWR_TO_D  ; VECT_RAWR_TO_D        
F1B0  F7FC                            fdb     STUB_INTA_TO_D  ; VECT_INTA_TO_D        
F1B2  F80B                            fdb     STUB_INTB_TO_D  ; VECT_INTB_TO_D        
F1B4  F81A                            fdb     STUB_INTR_TO_D  ; VECT_INTR_TO_D        
F1B6  F829                            fdb     STUB_8BIT_MATH  ; VECT_8BIT_MATH        
F1B8  F855                            fdb     STUB_DSP_ACA    ; VECT_DSP_ACA  
F1BA  F866                            fdb     STUB_DSP_ACB    ; VECT_DSP_ACB  
F1BC  F877                            fdb     STUB_DSP_ACR    ; VECT_DSP_ACR  
F1BE  F895                            fdb     STUB_DSP_INTA   ; VECT_DSP_INTA 
F1C0  F8A6                            fdb     STUB_DSP_INTB   ; VECT_DSP_INTB 
F1C2  F8B7                            fdb     STUB_DSP_INTR   ; VECT_DSP_INTR 
F1C4  F8DA                            fdb     STUB_WRITE_ACA  ; VECT_WRITE_ACA        
F1C6  F8EC                            fdb     STUB_WRITE_ACB  ; VECT_WRITE_ACB        
F1C8  F8FE                            fdb     STUB_WRITE_ACR  ; VECT_WRITE_ACR        
F1CA  F91E                            fdb     STUB_ARG_TO_A   ; VECT_ARG_TO_A 
F1CC                  SYSTEM_DATA_END
                      
                      
                      ; *****************************************************************************
                      ; * DEFAULT VECTORS                                                           *
                      ; *****************************************************************************
F1CC  39              EXEC_start      rts                     ; EXEC program
F1CD  7EF1CD          SWI3_start      jmp     SWI3_start      ; SWI3 Implementation
F1D0  7EF1D0          SWI2_start      jmp     SWI2_start      ; SYS (SWI2) Implementation
F1D3  7EF1D3          FIRQ_start      jmp     FIRQ_start      ; FIRQ Implementation
F1D6  7EF1D6          IRQ_start       jmp     IRQ_start       ; IRQ Implementation
F1D9  7EF1D9          SWI_start       jmp     SWI_start       ; SWI / SYS Implementation
F1DC  7EF1DC          NMI_start       jmp     NMI_start       ; NMI Implementation
F1DF  7EF1DF          RESET_start     jmp     RESET_start     ; RESET Implementation
                      
                      
                      ; *******************************************************************************
                      ; * KRNL_BEGIN                                                                  *
                      ; *     This is the primary entry point for the Kernel Rom.                     *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: NONE                                                    *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:    None                                                    *
                      ; * EXIT CONDITIONS:    None                                                    *
                      ; *                                                                             *
                      ; *******************************************************************************
F1E2                  KRNL_BEGIN      ; common start up code
F1E2  FC000E                          ldd     SOFT_RESET      ; load the soft reset vector
F1E5  10830000                        cmpd    #0              ; has it already been initialized?
F1E9  2704                            beq     KRNL_COLD       ; no? Well then, do a cold start
F1EB  6E9F000E                        jmp     [SOFT_RESET]    ; yes? Follow the warm reset vector     
                                      ; ...           
F1EF                  KRNL_COLD       ; cold reset
F1EF  8EFFF0                          ldx     #KRNL_HARD_VECT         ; start of the hardcoded CPU vectors
F1F2  CE0000                          ldu     #SOFT_VECTORS_DEVICE    ; start of the software vectors
F1F5  EC81            1               ldd     ,x++                    ; copy from hardcoded CPU vectors
F1F7  EDC1                            std     ,u++                    ; copy to the software vectors
F1F9  8C0000                          cmpx    #KRNL_HARD_VECT_END     ; at the end yet?
F1FC  2DF7                            blt     1b                      ; nope, keep going
F1FE  CCF22E                          ldd     #KRNL_WARM              ; fetch the warm reboot vector
F201  FD000E                          std     SOFT_RESET              ; ... and store it appropriately
                                      ; CPU clock speed       
F204  860F                            lda     #$0f                    ; set the CPU clock speed
F206  B7FE00                          sta     SYS_STATE               ;        to max
                                      ; ...           
                                      ; clear out system memory
F209  8E0010                          ldx     #SYSTEM_MEMORY_DEVICE   ; start of system memory
F20C  CC0000                          ldd     #$0000                  ; clear out D
F20F  BF0400          1               stx     VIDEO_START             ; cycle first character to show progress
F212  ED81                            std     ,x++                    ; clear out the next word of system memory
F214  8CB000                          cmpx    #USER_RAM_TOP           ; at the end yet?
F217  26F6                            bne     1b                      ; nope, keep going
                                      ; initialize the system 
F219  8EF182                          ldx     #SYSTEM_DATA_START
F21C  108E0010                        ldy     #$0010
F220  A680            1               lda     ,x+
F222  A7A0                            sta     ,y+
F224  8CF1CC                          cmpx    #SYSTEM_DATA_END
F227  2DF7                            blt     1b
                                      ; CPU clock speed
F229  860A                            lda     #$0a            ; set the default CPU clock speed
F22B  B7FE00                          sta     SYS_STATE       ;    to 900 Khz.
                      
                                      ; ...           
F22E                  KRNL_WARM       ; warm reboot
F22E  10CE0400                        lds     #SSTACK_TOP     ; give the stack a home
F232  864B                            lda     #$4B            ; $4B = green on dk.green
F234  B7005C                          sta     _ATTRIB         ; set the default text color attribute
                                      ; ...           
                                      ; set up the initial display
F237                                  sys     CALL_CLS        ; Clear the Text Screen
F237  103F                                swi2
F239  01                                  fcb \1
F23A  8EF003                          ldx     #KRNL_PROMPT0   ; Point X to the Kernel Version Text
F23D                                  sys     CALL_LINEOUT    ; Display the Text
F23D  103F                                swi2
F23F  05                                  fcb \1
F240  8EF021                          ldx     #KRNL_PROMPT1   ; Point X to the Compilation Text
F243                                  sys     CALL_LINEOUT    ; Display the Text
F243  103F                                swi2
F245  05                                  fcb \1
F246  8602                            lda     #FC_COMPDATE    ; command to fetch the compilation date
F248  B7FE76                          sta     FIO_COMMAND     ; issue the command to the FileIO device
F24B  B6FE7F          1               lda     FIO_PATH_DATA   ; load a character from the response data
F24E  2705                            beq     2f              ; if we've received a NULL, stop looping
F250                                  sys     CALL_CHROUT     ; output the retrieved character to the console
F250  103F                                swi2
F252  02                                  fcb \1
F253  20F6                            bra     1b              ; continue looping while there is still data
F255  860A            2               lda     #$0a            ; line feed character
F257                                  sys     CALL_CHROUT     ; send the line feed to the console                
F257  103F                                swi2
F259  02                                  fcb \1
F25A  8EF034                          ldx     #KRNL_PROMPT2   ; point to the third prompt line
F25D                                  sys     CALL_LINEOUT    ; output it to the console
F25D  103F                                swi2
F25F  05                                  fcb \1
F260  8EF05A                          ldx     #KRNL_PROMPT3   ; point to the fourth prompt line
F263                                  sys     CALL_LINEOUT    ; output it to the console
F263  103F                                swi2
F265  05                                  fcb \1
                                      ; ...           
                                      ; enable the mouse cursor
F266  B6FE45                          lda     CSR_FLAGS       ; load the mouse cursor flags
F269  8A08                            ora     #%1000'0000     ; set the enable bit
F26B  B7FE45                          sta     CSR_FLAGS       ; update the cursor flags
                                  
                      ; *****************************************************************************
                      ; * THE MAIN COMMAND LOOP                                                     *
                      ; *****************************************************************************
                      ; *                                                                           *
                      ; *     1) Displays the "Ready" prompt                                        *
                      ; *     2) Runs the Command Input Line Editor                                 *
                      ; *     3) Dispatches the Operating System Commands                           *
                      ; *                                                                           *
                      ; *****************************************************************************
F26E  F6005C          KRNL_MAIN_LOOP  ldb     _ATTRIB         ; fetch the current color attribute
F271  8EF082                          ldx     #READY_PROMPT   ; the ready prompt
F274                                  sys     CALL_LINEOUT    ; output to the console
F274  103F                                swi2
F276  05                                  fcb \1
                      
F277  867F                            lda     #$7F            ; Initialize the line editor
F279  B7FE60                          sta     EDT_BFR_LEN     ; allow for the full sized buffer
F27C  7FFE5E                          clr     EDT_BFR_CSR     ; set the buffer cursor to the start
F27F  7F0100                          clr     EDT_BUFFER                      
                      
F282  8E0100                          ldx     #EDT_BUFFER     ; point to the edit buffer
F285  6F80            k_main_clr      clr     ,x+             ; clear an entry and advance to next
F287  8C017F                          cmpx    #KEY_END        ; are we at the end of the buffer?
F28A  2DF9                            blt     k_main_clr      ;   not yet, continue looping
                      
F28C  BDF5A3          k_main_0        jsr     KRNL_LINEEDIT   ; run the command line editor
F28F  BDF6B9                          jsr     KRNL_CMD_PROC   ;    decode the command; A = Table Index
F292  7D0100                          tst     EDT_BUFFER      ; test the buffer for a null
F295  270D                            beq     k_main_cont     ; skip, nothing was entered
F297  81FF                            cmpa    #$FF            ; ERROR: command not found 
F299  2710                            beq     k_main_error    ;    display the error
F29B  48                              lsla                    ; index two byte addresses
F29C  3001                            leax    1,x
F29E  108EF0CF                        ldy     #KRNL_CMD_VECTS ; the start of the command vector table
F2A2  ADB6                            jsr     [a,y]           ; call the command subroutine
F2A4  7D0100          k_main_cont     tst     EDT_BUFFER      ; nothing entered in the command line?
F2A7  27E3                            beq     k_main_0        ;   nope, skip the ready prompt
F2A9  20C3                            bra     KRNL_MAIN_LOOP  ; back to the top of the main loop
F2AB  8EF0EB          k_main_error    ldx     #KRNL_ERR_NFND  ; ERROR: Command Not Found
F2AE  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F2B1  20F1                            bra     k_main_cont     ; continue within the main loop
                                      ; ...
F2B3                                  sys     CALL_GARBAGE
F2B3  103F                                swi2
F2B5  00                                  fcb \1
                                      ; infinite loop (for now)
F2B6  7EF2B6          KRNL_INF        jmp     KRNL_INF                        
                      
                      
                      
                      ; *****************************************************************************
                      ; * Command: CLS "Clear Screen"                       ARG1 = Color Attribute  *
                      ; *****************************************************************************
F2B9  6D84            do_cls          tst     ,x              ; test for an argument
F2BB  270F                            beq     do_cls_0        ; no argument, just go clear the screen
F2BD  A684                            lda     ,x              ; first character in the argument
F2BF  81FF                            cmpa    #$ff            ; $FF is also a terminator
F2C1  2709                            beq     do_cls_0        ; no argument, go clear the screen
F2C3  BDF91A                          jsr     KRNL_ARG_TO_A   ; fetch the numeric argument into A
F2C6  4D                              tsta                    ; is the numeric value 0?
F2C7  2703                            beq     do_cls_0        ; yeah, go clear the screen
F2C9  B7005C                          sta     _ATTRIB         ; store the argument as the default color
F2CC  8620            do_cls_0        lda     #' '            ; load the SPACE character to clear with
F2CE  F6005C                          ldb     _ATTRIB         ; load the color attribute
F2D1  BDF497                          jsr     KRNL_CLS        ; clear the screen
F2D4  39                              rts                     ; return from subroutine
                      
                      
                      ; *****************************************************************************
                      ; * Command: COLOR "Change the Color Attribute"       ARG1 = Color Attribute  *
                      ; *****************************************************************************
F2D5  6D84            do_color        tst     ,x              ; test for an argument
F2D7  270D                            beq     do_color_0      ; if its zero, do nothing; just return
F2D9  BDF91A                          jsr     KRNL_ARG_TO_A   ; fetch the numeric argument into A
F2DC  4D                              tsta                    ; is it a zero?
F2DD  2707                            beq     do_color_0      ;   yeah, return
F2DF  81FF                            cmpa    #$ff            ; is it the other terminator?
F2E1  2703                            beq     do_color_0      ;   yeah, return
F2E3  B7005C                          sta     _ATTRIB         ; save the new default color attribute
F2E6  39              do_color_0      rts                     ; return from subroutine
                      
                      
                      ; *****************************************************************************
                      ; * Command: LOAD "Load a (Intel) Hex File        ARG1 = {filepath}/filename  *
                      ; *****************************************************************************
F2E7  4552524F523A2046696C65204E6F7420466F756E640A00 err_file_nf     fcn     "ERROR: File Not Found\n";
F2FE  4552524F523A2046696C65204E6F74204F70656E0A00 err_file_no     fcn     "ERROR: File Not Open\n";
F314  4552524F523A2057726F6E672046696C6520547970650A00 err_wrong_file  fcn     "ERROR: Wrong File Type\n"
F32C  BDF35C          do_load         jsr     do_arg1_helper  ; fetch path data from argument 1
F32F  860A                            lda     #FC_LOADHEX     ; FIO Command
F331  B7FE76                          sta     FIO_COMMAND     ; Send the Load Hex Command
F334  B6FE75                          lda     FIO_ERROR       ; Examine the Error Code
F337  8101                            cmpa    #FE_NOTFOUND    ; is the File Not Found bit set?
F339  271A                            beq     do_ld_notfound  ; ERROR: File Not Found
F33B  8102                            cmpa    #FE_NOTOPEN     ; is the File Not Open bit set?
F33D  270E                            beq     do_ld_notopen   ; ERROR: File Not Open
F33F  8105                            cmpa    #FE_WRONGTYPE   ; is the Wrong File Type bit set?
F341  2702                            beq     do_ld_wrong     ; ERROR: Wrong File Type
F343  2016                            bra     do_ld_done      ; All done, return
F345  8EF314          do_ld_wrong     ldx     #err_wrong_file ; point to the error message
F348  BDF52F                          jsr     KRNL_LINEOUT    ; send the text to the console
F34B  200E                            bra     do_ld_done      ; done, return
F34D  8EF2FE          do_ld_notopen   ldx     #err_file_no    ; point to the error message
F350  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F353  2006                            bra     do_ld_done      ; done, return
F355  8EF2E7          do_ld_notfound  ldx     #err_file_nf    ; point to the error message
F358  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F35B  39              do_ld_done      rts                     ; done, return
F35C  7FFE7E          do_arg1_helper  clr     FIO_PATH_POS    ; reset the path cursor position
F35F  A680            do_argh_0       lda     ,x+             ; load the next character
F361  B7FE7F                          sta     FIO_PATH_DATA   ; push it into the FIO Path Data Port
F364  26F9                            bne     do_argh_0       ; Continue until Null-Terminator
F366  39                              rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: EXEC "Execute a Program"                            ARG1 = none  *
                      ; *****************************************************************************
F367  AD9F0000        do_exec         jsr     [VEC_EXEC]      ; call the users program
F36B  39                              rts                     ; return from this subroutine
                      
                      ; *****************************************************************************
                      ; * Command: RESET "Perform a System Reset"                      ARG1 = none  *
                      ; *****************************************************************************
F36C  8600            do_reset        lda     #FC_RESET       ; load the FIO Command: RESET
F36E  B7FE76                          sta     FIO_COMMAND     ; issue the Command
F371  39                              rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: DIR "List a Directorys Files and Folders"     ARG1 = {filepath}  *
                      ; *****************************************************************************
F372  8DE8            do_dir          bsr     do_arg1_helper  ; fetch path data from argument 1
F374  860C                            lda     #FC_LISTDIR     ; load the FIO command: LISTDIR
F376  B7FE76                          sta     FIO_COMMAND     ; issue the Command
F379  B6FE83          do_dir_1        lda     FIO_DIR_DATA    ; load a character from the Data Port
F37C  2705                            beq     do_dir_2        ; quit when we find the Null-Terminator
F37E  BDF4BA                          jsr     KRNL_CHROUT     ; output the character to the console
F381  20F6                            bra     do_dir_1        ; continue looping until done
F383  39              do_dir_2        rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: CD / CHDIR "Change Current Folder"            ARG1 = {filepath}  *
                      ; *****************************************************************************
F384                  do_cd                                   ; CD is an alias for CHDIR
F384  8DD6            do_chdir        bsr     do_arg1_helper  ; fetch path data from argument 1
F386  860E                            lda     #FC_CHANGEDIR   ; load the FIO command: CHANGEDIR
F388  B7FE76                          sta     FIO_COMMAND     ; send it; change dir
F38B  7EF38E                          jmp     do_pwd          ; output the current working directory
                      
                      ; *****************************************************************************
                      ; * Command: PWD "Print Working Directory"                       ARG1 = none  *
                      ; *****************************************************************************
F38E  860F            do_pwd          lda     #FC_GETPATH     ; load the FIO command: GETPATH 
F390  B7FE76                          sta     FIO_COMMAND     ; send it; fetch the current path
F393  7FFE7E                          clr     FIO_PATH_POS    ; reset the path cursor position
F396  B6FE7F          do_pwd_0        lda     FIO_PATH_DATA   ; pull a character from the path data port
F399  2705                            beq     do_pwd_1        ; if it's a null, we're done
F39B  BDF4BA                          jsr     KRNL_CHROUT     ; output the character to the console
F39E  20F6                            bra     do_pwd_0        ; continue looping until done
F3A0  39              do_pwd_1        rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: EXIT / QUIT "Terminate the Emulator Program"        ARG1 = none  *
                      ; *****************************************************************************
F3A1  12              do_exit         nop                     ; EXIT is an alias for QUIT
F3A2  8601            do_quit         lda     #FC_SHUTDOWN    ; load the FIO command: SHUTDOWN
F3A4  B7FE76                          sta     FIO_COMMAND     ; issue the shutdown command
F3A7  39                              rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: MODE "Change Display Mode" (sets GMODE)    ARG1 = Graphics Mode  *
                      ; *****************************************************************************
F3A8  6D84            do_mode         tst     ,x              ; test for an argument
F3AA  2718                            beq     do_mode_0       ; just return if argument == zero
F3AC  BDF91A                          jsr     KRNL_ARG_TO_A   ; fetch the numeric argument into A 
F3AF  8407                            anda    #%00000111      ; mask out the mode bits
F3B1  B70062                          sta     _LOCAL_3        ; store the mode bits
F3B4  B6FE0C                          lda     GPU_MODE_LSB    ; fetch the current mode lsb
F3B7  84F8                            anda    #%11111000      ; mask out the mode bits
F3B9  BA0062                          ora     _LOCAL_3        ; or them back in
F3BC  B7FE0C                          sta     GPU_MODE_LSB    ; set the GMODE 
F3BF  8620                            lda     #' '            ; load a SPACE character
F3C1  BDF497                          jsr     KRNL_CLS        ; clear the screen
F3C4  39              do_mode_0       rts                     ; return from subroutine
                      
                      ; *****************************************************************************
                      ; * Command: DEBUG "Enter / Exit Debugger"                       ARG1 = none  *
                      ; *****************************************************************************
F3C5  2000            do_debug_str    fcn     " ";
F3C7  656E61626C65640A00 do_debug_ena    fcn     "enabled\n";
F3D0  64697361626C65640A00 do_debug_dis    fcn     "disabled\n";
F3DA  B6FE0A          do_debug        lda     SYS_DBG_FLAGS   ; load the debug hardware flags
F3DD  8480                            anda    #$80            ; test the enable bit
F3DF  2715                            beq     do_debug_0      ; Go ENABLE the debugger
                                      ; DISABLE the debugger
F3E1  B6FE0A                          lda     SYS_DBG_FLAGS   ; load the debug hardware flags
F3E4  847F                            anda    #$7f            ; mask out the debugger bit
F3E6  B7FE0A                          sta     SYS_DBG_FLAGS   ; store the updated debug flags
F3E9  8EF3C5                          ldx     #do_debug_str   ; load the debugger response string
F3EC  BDF52F                          jsr     KRNL_LINEOUT    ; send the string to the console
F3EF  8EF3D0                          ldx     #do_debug_dis   ; load the "disabled" string address
F3F2  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F3F5  39                              rts                     ; return from this subroutine
F3F6                  do_debug_0      ; ENABLE the debugger
F3F6  B6FE0A                          lda     SYS_DBG_FLAGS   ; load the debug hardware flags
F3F9  8A80                            ora     #$80            ; set the debug enable flag
F3FB  B7FE0A                          sta     SYS_DBG_FLAGS   ; store the updated debug flags
F3FE  8EF3C5                          ldx     #do_debug_str   ; load the debugger response string
F401  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F404  8EF3C7                          ldx     #do_debug_ena   ; load the "enabled" string start
F407  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F40A  39                              rts                     ; return from this subroutine
                      
                      ; *****************************************************************************
                      ; * Command: HELP basic help text message                        ARG1 = none  *
                      ; *****************************************************************************
F40B  8EF105          do_help         ldx     #krnl_help_str  ; load the help message string addresses
F40E  BDF52F                          jsr     KRNL_LINEOUT    ; send it to the console
F411  39                              rts                     ; return from subroutine
                      
                      
                      ; *******************************************************************************
                      ; * System Call Handler:                                                        *
                      ; *                                                                             *
                      ; *     References the byte immediately following the SWI2 instruction and      *
                      ; *     dispatches to the appropriate system call based on that value.          *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: Varies                                                  *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:    Varies                                                  *
                      ; *                                                                             *
                      ; * Notes: (See Kernel_Header.asm)                                              *
                      ; *     Common Stack Offsets:                                                   *
                      ; *         CC  =  0,S                                                          *
                      ; *         D   =  1,S                                                          *
                      ; *         A   =  1,S                                                          *
                      ; *         B   =  2,S                                                          *
                      ; *         DP  =  3,S                                                          *
                      ; *         X   =  4,S                                                          *
                      ; *         Y   =  6,S                                                          *
                      ; *         U   =  8,S                                                          *
                      ; *         PC  = 10,S                                                          *
                      ; *                                                                             *
                      ; *******************************************************************************
F412  F47A            KRNL_SYS_CALLS  fdb     SYS_GARBAGE     ; $00 random garbage
F414  F493                            fdb     SYS_CLS         ; $01 CLS               
F416  F4B4                            fdb     SYS_CHROUT      ; $02 CHROUT            
F418  F4EF                            fdb     SYS_NEWLINE     ; $03 NEWLINE           
F41A  F50F                            fdb     SYS_TAB         ; $04 TAB               
F41C  F529                            fdb     SYS_LINEOUT     ; $05 LINEOUT           
F41E  F547                            fdb     SYS_CSRPOS      ; $06 CSRPOS            
F420  F569                            fdb     SYS_SCROLL      ; $07 SCROLL            
F422  F59F                            fdb     SYS_LINEEDIT    ; $08 LINEEDIT          
F424  F627                            fdb     SYS_GETKEY      ; $09 GETKEY            
F426  F640                            fdb     SYS_GETHEX      ; $0A GETHEX            
F428  F668                            fdb     SYS_GETNUM      ; $0B GETNUM            
F42A  F680                            fdb     SYS_CMPSTR      ; $0C CMPSTR            
F42C  F6B5                            fdb     SYS_CMD_PROC    ; $0D CMD_PROC          
F42E  F712                            fdb     SYS_TBLSEARCH   ; $0E TBLSEARCH         
F430  F735                            fdb     SYS_CPY_DWORD   ; $0F CPY_DWORD         
F432  F749                            fdb     SYS_D_TO_RAWA   ; $10 SYS_D_TO_RAWA
F434  F75E                            fdb     SYS_D_TO_RAWB   ; $11 SYS_D_TO_RAWB
F436  F773                            fdb     SYS_D_TO_RAWR   ; $12 SYS_D_TO_RAWR
F438  F788                            fdb     SYS_D_TO_INTA   ; $13 SYS_D_TO_INTA
F43A  F79D                            fdb     SYS_D_TO_INTB   ; $14 SYS_D_TO_INTB
F43C  F7B2                            fdb     SYS_D_TO_INTR   ; $15 SYS_D_TO_INTR
F43E  F7C7                            fdb     SYS_RAWA_TO_D   ; $16 SYS_RAWA_TO_D
F440  F7D6                            fdb     SYS_RAWB_TO_D   ; $17 SYS_RAWB_TO_D
F442  F7E5                            fdb     SYS_RAWR_TO_D   ; $18 SYS_RAWR_TO_D
F444  F7F4                            fdb     SYS_INTA_TO_D   ; $19 SYS_INTA_TO_D
F446  F803                            fdb     SYS_INTB_TO_D   ; $1A SYS_INTB_TO_D
F448  F812                            fdb     SYS_INTR_TO_D   ; $1B SYS_INTR_TO_D
F44A  F821                            fdb     SYS_8BIT_MATH   ; $1C SYS_8BIT_MATH
F44C  F84D                            fdb     SYS_DSP_ACA     ; $1D SYS_DSP_ACA
F44E  F85E                            fdb     SYS_DSP_ACB     ; $1E SYS_DSP_ACB
F450  F86F                            fdb     SYS_DSP_ACR     ; $1F SYS_DSP_ACR
F452  F88D                            fdb     SYS_DSP_INTA    ; $20 SYS_DSP_INTA
F454  F89E                            fdb     SYS_DSP_INTB    ; $21 SYS_DSP_INTB
F456  F8AF                            fdb     SYS_DSP_INTR    ; $22 SYS_DSP_INTR
F458  F8D2                            fdb     SYS_WRITE_ACA   ; $23 SYS_WRITE_ACA
F45A  F8E4                            fdb     SYS_WRITE_ACB   ; $24 SYS_WRITE_ACB
F45C  F8F6                            fdb     SYS_WRITE_ACR   ; $25 SYS_WRITE_ACR
F45E  F916                            fdb     SYS_ARG_TO_A    ; $26 SYS_ARG_TO_A
F460                  KRNL_SYS_CALLS_END                              
                                      
                      
F460                  SYS_Handler     ; increment the return address on the stack past the command byte
F460  EE6A                            ldu     $000a,S         ; fetch the command that follows the SWI2
F462  E6C4                            ldb     0,U             ; load the command into B
F464  3341                            leau    1,U             ; address just past the command byte
F466  EF6A                            stu     $000a,S         ; update the return address in the stack
F468  CEF412                          ldu     #KRNL_SYS_CALLS ; system call vector base address
F46B  58                              lslb                    ; each address is two bytes long
F46C  33C5                            leau    B,U             ; U = system call vector effective address
F46E  1183F460                        cmpu    #KRNL_SYS_CALLS_END ; Bounds check
F472  2C02                            bge     SYS_HNDLR_DONE  ; system call out of bounds; error
F474  6ED4                            jmp     [,U]            ; take the appropriate system call vector
F476                  SYS_HNDLR_DONE  ; Error Condition -- System Call Out of Bounds
                                      ; ...  (ToDo)
F476  7EF47E                          jmp     KRNL_GARBAGE    ; temporary fatal error
                                      ; ...
F479  3B                              rti ; Reminder: This Sub is an Interrupt
                      
                      
                      ; This is just a temporary place holder for a terminal system crash.
                      ; cycle video memory (infinite loop)
F47A  BDF47E          SYS_GARBAGE     jsr     KRNL_GARBAGE    ; call the kernel error handler (temp)
F47D  3B                              rti                     ; return from the sys interrupt
F47E                  KRNL_GARBAGE                    
F47E  CC0100                          ldd     #$0100          ; initialize a starting attribute/character pair
F481  8E0400          1               ldx     #VIDEO_START    ; point to the start of the text display
F484  C30001                          addd    #1              ; increment the attribute/character to display
F487  ED81            2               std     ,x++            ; store the colored character to the next cell
F489  C30001                          addd    #1              ; increment the attribute/character to display
F48C  BCFE0D                          cmpx    GPU_VIDEO_MAX   ; at the end of displayed video memory?
F48F  2DF6                            blt     2b              ; nope, keep going with the next character
F491  20EE                            bra     1b              ; yup, start over.
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CLS                                                                  *
                      ; *     Clears the currently displayed screen buffer                          *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: Screen will be cleared with spaces with the color     *
                      ; *     stored in _ATTRIB.                                                    *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F493  BDF497          SYS_CLS         jsr     KRNL_CLS        ; call the kernel Clear Screen handler
F496  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F497  6E9F0010        KRNL_CLS        jmp     [VEC_CLS]       ; proceed through the software vector
F49B  3416            STUB_CLS        pshs    d,x             ; save the used registers onto the stack
F49D  B6005C                          lda     _ATTRIB         ; fetch the current color attribute
F4A0  C620                            ldb     #' '            ; the space character
F4A2  8E0400                          ldx     #VIDEO_START    ; index the start of the video buffer
F4A5  ED81            1               std     ,x++            ; store a character to the buffer
F4A7  BCFE0D                          cmpx    GPU_VIDEO_MAX   ; are we at the end yet?
F4AA  2DF9                            blt     1b              ; nope, keep storing characters
F4AC  7F005A                          clr     _CURSOR_COL     ; clear the current cursor position ...
F4AF  7F005B                          clr     _CURSOR_ROW     ; ... column and row the home (top/left)
F4B2  3596                            puls    d,x,pc          ; cleanup and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CHROUT                                                               *
                      ; *     Outputs a character to the console at the current cursor              *
                      ; *     position. This routine should update the cursors postion              *
                      ; *     and handle text scrolling as needed.                                  *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: A = Character to be displayed                         *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F4B4  A661            SYS_CHROUT      lda     1,S             ; fetch A from the stack
F4B6  BDF4BA                          jsr     KRNL_CHROUT     ; call the character out kernel handler
F4B9  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F4BA  6E9F0012        KRNL_CHROUT     jmp     [VEC_CHROUT]    ; proceed through the software vector
F4BE  3417            STUB_CHROUT     pshs    d,x,cc          ; save the used registers onto the stack
F4C0  1F89                            tfr     a,b
F4C2  B6005C                          lda     _ATTRIB         ; load the current color attribute
F4C5  5D              K_CHROUT_1      tstb                    ; is A a null?
F4C6  2725                            beq     K_CHROUT_DONE   ;    A is null, just return and do nothing              
F4C8  C10A                            cmpb    #$0A            ; is it a newline character?
F4CA  2605                            bne     K_CHROUT_2      ; nope, don't do a newline
F4CC  BDF4F3                          jsr     KRNL_NEWLINE    ; advance the cursor 
F4CF  201C                            bra     K_CHROUT_DONE   ; clean up and return
F4D1  C109            K_CHROUT_2      cmpb    #$09            ; is it a tab character?
F4D3  2605                            bne     K_CHROUT_0      ; nope, don't do a tab
F4D5  BDF513                          jsr     KRNL_TAB        ; tab the character position
F4D8  2013                            bra     K_CHROUT_DONE   ; clean up and return
F4DA  BDF54D          K_CHROUT_0      jsr     KRNL_CSRPOS     ; position X at the cursor position
F4DD  ED84                            std     ,x              ; display the character/attribute combo
F4DF  7C005A                          inc     _CURSOR_COL     ; increment current cursor column position
F4E2  B6005A                          lda     _CURSOR_COL     ; load current cursor column position                                   
F4E5  B1FE13                          cmpa    GPU_TCOLS       ; compare with the current screen columns
F4E8  2D03                            blt     K_CHROUT_DONE   ; if the csr column is okay, we're done
F4EA  BDF4F3                          jsr     KRNL_NEWLINE    ; perform a new line
F4ED  3597            K_CHROUT_DONE   puls    d,x,cc,pc       ; cleanup and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_NEWLINE                                                              *
                      ; *     Perfoms a CR/LF ($0A) on the console. Advances the current            *
                      ; *     cursor position and scrolls the console if needed.                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F4EF  BDF4F3          SYS_NEWLINE     jsr     KRNL_NEWLINE    ; call the newline kernel handler
F4F2  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F4F3  6E9F0014        KRNL_NEWLINE    jmp     [VEC_NEWLINE]   ; proceed through the software vector
F4F7  3416            STUB_NEWLINE    pshs    D,X             ; save the used registers onto the stack
F4F9  7F005A                          clr     _CURSOR_COL     ; carrage return (move to left edge)
F4FC  7C005B                          inc     _CURSOR_ROW     ; increment the cursors row
F4FF  B6005B                          lda     _CURSOR_ROW     ; load the current row
F502  B1FE14                          cmpa    GPU_TROWS       ; compared to the current screen rows
F505  2D06                            blt     K_NEWLINE_DONE  ; clean up and return if less than
F507  7A005B                          dec     _CURSOR_ROW     ; move the cursor the the bottom row
F50A  BDF56D                          jsr     KRNL_SCROLL     ; scroll the text screen up one line
F50D  3596            K_NEWLINE_DONE  puls    D,X,PC          ; restore the saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_TAB                                                                  *
                      ; *     Perfoms a tab ($0A) on the console. Advances the current              *
                      ; *     cursor position and scrolls the console if needed.                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F50F  BDF513          SYS_TAB         jsr     KRNL_TAB        ; call the tab character kernel handler
F512  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F513  3404            KRNL_TAB        pshs    b               ; save B
F515  F6005A                          ldb     _CURSOR_COL     ; Fetch the current cursor col
F518  CB04                            addb    #4              ; Move cursor by 4 spaces
F51A  C4FC                            andb    #%11111100      ; Align to the next tab stop
F51C  F7005A                          stb     _CURSOR_COL     ; update the cursor column
F51F  F1FE13                          cmpb    GPU_TCOLS       ; Ensure column is within bounds
F522  2D03                            blt     K_TAB_DONE      ; Within bounds, we're done
F524  BDF4F3                          jsr     KRNL_NEWLINE    ; Handle line wrapping
F527  3584            K_TAB_DONE      puls    B,PC            ; cleanup and return
                      
                      
                      ; *******************************************************************************
                      ; * KRNL_LINEOUT                                                                *
                      ; *     Outputs a string to the console                                         *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: X = String starting address                             *
                      ; *                         (null terminated)                                   *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:    All registers preserved.                                *
                      ; *******************************************************************************
F529  AE64            SYS_LINEOUT     ldx     4,S             ; fetch X from the stack
F52B  BDF52F                          jsr     KRNL_LINEOUT    ; call the line out kernel handler
F52E  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F52F  6E9F0016        KRNL_LINEOUT    jmp     [VEC_LINEOUT]   ; proceed through the software vector
F533  3456            STUB_LINEOUT    pshs    D,X,U           ; save the used registers onto the stack
F535  1F13                            tfr     X,U             ; move X to U
F537  BDF54D                          jsr     KRNL_CSRPOS     ; set X to the cursor position 
F53A  A6C0            K_LINEOUT_0     lda     ,U+             ; fetch the next character
F53C  2707                            beq     K_LINEOUT_DONE  ; cleanup and return if null-terminator         
F53E  BDF4BA                          jsr     KRNL_CHROUT     ; send the character to the console
F541  3001                            leax    1,X             ; point to the next character
F543  20F5                            bra     K_LINEOUT_0     ; continue looping until done
F545  35D6            K_LINEOUT_DONE  puls    D,U,X,PC        ; restore the saved registers and return
                      
                      
                      ; *******************************************************************************
                      ; * KRNL_CSRPOS                                                                 *
                      ; *     Loads into X the cursor position                                        *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS:                                                         *
                      ; *     _CURSOR_COL     =   (Byte) Current Text Cursor Column Position          *
                      ; *     _CURSOR_ROW     =   (Byte) Current Text Cursor Row Position             *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:    X = The address within the text                         *
                      ; *                         where the cursor is positioned.                     *   
                      ; *                     All other registers preserved.                          *
                      ; *******************************************************************************
F547  BDF54D          SYS_CSRPOS      jsr     KRNL_CSRPOS     ; call the CSRPOS kernel subroutine
F54A  AF64                            stx     4,S             ; replace X in the stack so it has ...
F54C  3B                              rti                     ; ... valid info on return
                                      ; ...
F54D  6E9F0018        KRNL_CSRPOS     jmp     [VEC_CSRPOS]    ; proceed through the software vector
F551  3406            STUB_CSRPOS     pshs    D               ; save the used registers onto the stack
F553  B6005B                          lda     _CURSOR_ROW     ; current cursor row
F556  F6FE13                          ldb     GPU_TCOLS       ; current text columns
F559  58                              lslb                    ; times two (account for the attribute)
F55A  3D                              mul                     ; row * columns
F55B  8E0400                          ldx     #VIDEO_START    ; the buffer starting address
F55E  308B                            leax    D,X             ; add the video base address
F560  F6005A                          ldb     _CURSOR_COL     ; load the current cursor column
F563  58                              lslb                    ; times two (account for the attribute)
F564  4F                              clra                    ; don't let B become negative, use D
F565  308B                            leax    D,X             ; add the column to the return address
F567  3586                            puls    D,PC            ; restore the saved registers and return
                      
                      ; *****************************************************************************
                      ; * KRNL_SCROLL                                                               *
                      ; *     Scroll the text screen up one line and blank the bottom line.         *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F569  BDF56D          SYS_SCROLL      jsr     KRNL_SCROLL     ; call the text screen scroll handler
F56C  3B                              rti                     ; return from the sys interrupt
                                      ; ...
F56D  6E9F001A        KRNL_SCROLL     jmp     [VEC_SCROLL]    ; proceed through the software vector
F571  3456            STUB_SCROLL     pshs    d,x,u           ; save the used registers onto the stack
F573  8E0400                          ldx     #VIDEO_START    ; set X to the start of the video buffer
F576  1F13                            tfr     x,u             ; copy X into U
F578  F6FE13                          ldb     GPU_TCOLS       ; B = Screen Columns
F57B  58                              lslb                    ; account for the attribute byte
F57C  4F                              clra                    ; MSB of D needs to not be negative
F57D  33CB                            leau    d,u             ; U is now one line below X
F57F  ECC1            K_SCROLL_0      ldd     ,u++            ; load a character from where U points
F581  ED81                            std     ,x++            ; store it to where X points
F583  11B3FE0D                        cmpu    GPU_VIDEO_MAX   ; has U exceeded the screen buffer
F587  2DF6                            blt     K_SCROLL_0      ; continue looping of not
F589  B6005C                          lda     _ATTRIB
F58C  C620                            ldb     #' '            ; set SPACE as the current character
F58E  ED81            K_SCROLL_1      std     ,x++            ; and store it to where X points
F590  BCFE0D                          cmpx    GPU_VIDEO_MAX   ; continue looping until the bottom ...
F593  2DF9                            blt     K_SCROLL_1      ; ... line has been cleared
F595  7DFE5F                          tst     EDT_ENABLE      ; are we using the line editor?
F598  2703                            beq     K_SCROLL_DONE   ; nope, just clean up and return
F59A  7A005E                          dec     _ANCHOR_ROW     ; yup, decrease the anchor row by one
F59D  35D6            K_SCROLL_DONE   puls    d,x,u,pc        ; restore the registers and return
                      
                      ; *****************************************************************************
                      ; * KRNL_LINEEDIT                                                             *
                      ; *     Engage the text line editor,                                          *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved.                              *
                      ; *****************************************************************************
F59F  BDF5A3          SYS_LINEEDIT    jsr     KRNL_LINEEDIT   ; call the text line edit kernel handler
F5A2  3B                              rti                     ; return from the interrupt
                                      ; ...
F5A3  6E9F001C        KRNL_LINEEDIT   jmp     [VEC_LINEEDIT]  ; proceed through the software vector
F5A7  3457            STUB_LINEEDIT   pshs    D,X,U,CC        ; save the used registers onto the stack                
F5A9  FC005A                          ldd     _CURSOR_COL     ; load the current cursor position
F5AC  FD005D                          std     _ANCHOR_COL     ;   use it to update the anchor position
F5AF  8601                            lda     #1              ; load the enable condition
F5B1  B7FE5F                          sta     EDT_ENABLE      ; to enable the line editor
F5B4                  KRNL_LEDIT_0    ; display the line up to the cursor             
F5B4  FC005D                          ldd     _ANCHOR_COL     ; restore the line editor anchor
F5B7  FD005A                          std     _CURSOR_COL     ; into the console cursor position
F5BA  CE0100                          ldu    #EDT_BUFFER      ; point to the start of the edit buffer
F5BD  F6FE5E                          ldb    EDT_BFR_CSR      ; the buffer csr position
F5C0  F7005F                          stb    _LOCAL_0         ; store the edit csr position locally
F5C3  7D005F          KRNL_LEDIT_1    tst    _LOCAL_0         ; test the edit csr position
F5C6  270C                            beq     KRNL_LEDIT_2    ; if we're there, go display the cursor
F5C8  7A005F                          dec     _LOCAL_0        ; decrement the edit csr position
F5CB  A6C0                            lda     ,u+             ; load the next character from the buffer
F5CD  2705                            beq     KRNL_LEDIT_2    ; display csr if at the null terminator
F5CF  BDF4BA                          jsr     KRNL_CHROUT     ; output the character to the console
F5D2  20EF                            bra     KRNL_LEDIT_1    ; loop until we're at the cursor
F5D4                  KRNL_LEDIT_2    ; display the cursor at the end of the line
F5D4  8620                            lda     #' '            ; load a blank SPACE character
F5D6  F6FE03                          ldb     SYS_CLOCK_DIV   ; load clock timer data
F5D9  58                              lslb                    ; times two
F5DA  C4F0                            andb    #$F0            ; B now holds color cycled attribute
F5DC  6DC4                            tst     ,u              ; test the next character in the buffer
F5DE  2702                            beq     KRNL_LEDIT_3    ; use the SPACE if we're at a null
F5E0  A6C0                            lda     ,u+             ; load the next character from buffer
F5E2                  KRNL_LEDIT_3    ; finish the line
F5E2  BDF54D                          jsr     KRNL_CSRPOS     ; load X with the current cursor position 
F5E5  1E89                            exg     a,b
F5E7  ED84                            std     ,x              ; store the character where X points to
F5E9  7C005A                          inc     _CURSOR_COL     ; ipdate the cursor column number
                                      ; ldb   KRNL_ATTRIB     ; load the default color attribute
F5EC  A6C0            KRNL_LEDIT_4    lda     ,u+             ; fetch the next character from the buffer
F5EE  2705                            beq     KRNL_DONE       ; if it's null, we're done
F5F0  BDF4BA                          jsr     KRNL_CHROUT     ; output it to the console
F5F3  20F7                            bra     KRNL_LEDIT_4    ; continue looping until we find the null
F5F5                  KRNL_DONE       ; space at the end      
F5F5  8620                            lda     #' '            ; load the SPACE character
F5F7  BDF54D                          jsr     KRNL_CSRPOS     ; fetch the cursor position into X
F5FA  8620                            lda     #' '            ; load the SPACE character
F5FC  F6005C                          ldb     _ATTRIB         ; load the current color attribute
F5FF  1E89                            exg     a,b
F601  ED84                            std     ,x              ; update the console
                                      ; test for the user pressing ENTER / RETURN
F603  B6FE4D                          lda     CHAR_POP        ; Pop the top key from the queue
F606  27AC                            beq     KRNL_LEDIT_0    ; loop to the top if no keys we're pressed
F608  810D                            cmpa    #$0d            ; check for the RETURN / ENTER key press
F60A  26A8                            bne     KRNL_LEDIT_0    ; if not pressend, loop back to the top         
F60C  7FFE5F                          clr     EDT_ENABLE      ; disable the line editor               
F60F  BDF54D                          jsr     KRNL_CSRPOS     ; load the cursor position into X
F612  B6005C                          lda     _ATTRIB
F615  C620                            ldb     #' '            ; load a SPACE character
F617  ED1E                            std     -2,x            ; store the character, clean up artifacts
F619  FC005D                          ldd     _ANCHOR_COL     ; restore the line editor anchor
F61C  FD005A                          std     _CURSOR_COL     ; into the console cursor position
F61F  8E0100                          ldx     #EDT_BUFFER     ; point to the edit buffer
F622  BDF52F                          jsr     KRNL_LINEOUT    ; send the edit buffer to the console
F625  35D7                            puls    D,X,U,CC,PC     ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_GETKEY                                                               *
                      ; *     Input a character from the console. Waits for the keypress.           *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = key code of the key that was pressed              *
                      ; *                         All other registers preserved                     *
                      ; *****************************************************************************
F627  BDF62B          SYS_GETKEY      jsr     KRNL_GETKEY     ; call the kernel get key handler
F62A  3B                              rti                     ; return from interrupt
                                      ; ...
F62B  6E9F001E        KRNL_GETKEY     jmp     [VEC_GETKEY]    ; proceed through the software vector    
F62F  3405            STUB_GETKEY     pshs    b,CC            ; save the used registers onto the stack
F631  F6FE4D          K_GETKEY_0      ldb     CHAR_POP        ; pop the next key from the queue
F634  26FB                            bne     K_GETKEY_0      ; continue until the queue is empty             
F636  F6FE4B          K_GETKEY_1      ldb     CHAR_Q_LEN      ; how many keys are in the queue
F639  27FB                            beq     K_GETKEY_1      ; loop until a key is queued
F63B  B6FE4D                          lda     CHAR_POP        ; pop the key into A to be returned
F63E  3585                            puls    b,CC,PC         ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_GETHEX                                                               *
                      ; *     Input a hex digit from the console. Waits for the keypress.           *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = key code of the key that was pressed              *
                      ; *                         All other registers preserved                     *
                      ; *****************************************************************************
F640  BDF644          SYS_GETHEX      jsr     KRNL_GETHEX     ; call the kernel GetHex handler
F643  3B                              rti
                                      ; ...
F644  6E9F0020        KRNL_GETHEX     jmp     [VEC_GETHEX]    ; proceed through the software vector
F648  3401            STUB_GETHEX     pshs    CC              ; save the used registers onto the stack
F64A  8DDF            K_GETHEX_0      bsr     KRNL_GETKEY     ; wait for and fetch a key press
F64C  8130                            cmpa    #'0'            ; compare with the '0' key
F64E  2DFA                            blt     K_GETHEX_0      ; keep scanning if less
F650  8139                            cmpa    #'9'            ; compare with the '9' key
F652  2312                            bls     K_GETHEX_DONE   ; found an appropriate key, return
F654  8141                            cmpa    #'A'            ; compare with the 'A' key
F656  2DF2                            blt     K_GETHEX_0      ; keep scanning if less
F658  8146                            cmpa    #'F'            ; compare with the 'F' key
F65A  230A                            bls     K_GETHEX_DONE   ; found an appropriate key, return
F65C  8161                            cmpa    #'a'            ; compare with the 'a' key
F65E  2DEA                            blt     K_GETHEX_0      ; keep scanning if less
F660  8166                            cmpa    #'f'            ; compare with the 'f' key
F662  2302                            bls     K_GETHEX_DONE   ; found an appropriate key, return
F664  20E4                            bra     K_GETHEX_0      ; keep scanning
F666  3581            K_GETHEX_DONE   puls    CC,PC           ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_GETNUM                                                               *
                      ; *     Input a numeric digit from the console. Waits for the keypress.       *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: NONE                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = key code of the key that was pressed              *
                      ; *                         All other registers preserved                     *
                      ; *****************************************************************************
F668  BDF66C          SYS_GETNUM      jsr     KRNL_GETNUM     ; call the kernel GetNum handler
F66B  3B                              rti     ; return from interrupt
                                      ; ...
F66C  6E9F0022        KRNL_GETNUM     jmp     [VEC_GETNUM]    ; proceed through the software vector
F670  3401            STUB_GETNUM     pshs    CC              ; save the used registers onto the stack
F672  8DB7            K_GETNUM_0      bsr     KRNL_GETKEY     ; wait for and fetch a key press
F674  8130                            cmpa    #'0'            ; compare with the '0' key
F676  2DFA                            blt     K_GETNUM_0      ; keep scanning if less
F678  8139                            cmpa    #'9'            ; compare with the '9' key
F67A  2302                            bls     K_GETNUM_DONE   ; found an appropriate key, return
F67C  20F4                            bra     K_GETNUM_0      ; keep scanning
F67E  3581            K_GETNUM_DONE   puls    CC,PC           ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CMPSTR                                                               *
                      ; *     Compare two null-terminated strings of arbitrary lengths.             *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X = starting address of string 1                      *
                      ; *                     Y = starting address of string 2                      *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    CC = set per the comparison (less, greater, or same)  *
                      ; *                     X = address last checked in string 1                  *
                      ; *                     Y = address last checked in string 2                  *
                      ; *****************************************************************************
F680  BDF684          SYS_CMPSTR      jsr     KRNL_CMPSTR     ; call the kernel CMPSTR handler
F683  3B                              rti                     ; return from the interrupt
                                      ; ...
F684  6E9F0024        KRNL_CMPSTR     jmp     [VEC_CMPSTR]    ; proceed through the software vector
F688  3406            STUB_CMPSTR     pshs    D               ; save the used registers onto the stack                
F68A  6D84            K_CMP_LOOP      tst     ,x              ; test the current character in string 1
F68C  2606                            bne     K_CMP_1         ; if its non-null, go test in string 2
F68E  6DA4                            tst     ,y              ; test if character in both are null
F690  271E                            beq     K_CMP_EQUAL     ; if so, strings are equal
F692  2010                            bra     K_CMP_LESS      ; is LESS if str1 is null but str2 is not
F694  6DA4            K_CMP_1         tst     ,y              ; char in str1 is not null, but str2 is
F696  2712                            beq     K_CMP_GREATER   ; return GREATER
F698  A680                            lda     ,x+             ; compare character from string 1
                                      ;
F69A  8A20                            ora     #$20            ; convert all letters to lower case
                                      ;
F69C  A1A0                            cmpa    ,y+             ;    with character from string 2
F69E  2D04                            blt     K_CMP_LESS      ; return LESS
F6A0  2E08                            bgt     K_CMP_GREATER   ; return GREATER
F6A2  20E6                            bra     K_CMP_LOOP      ; otherwise continue looping
F6A4  8601            K_CMP_LESS      lda     #1              ; compare 1
F6A6  8102                            cmpa    #2              ;    with 2
F6A8  2009                            bra     K_CMP_DONE      ; return LESS
F6AA  8602            K_CMP_GREATER   lda     #2              ; compare 2
F6AC  8101                            cmpa    #1              ;    with 1
F6AE  2003                            bra     K_CMP_DONE      ; return GREATER
F6B0  4F              K_CMP_EQUAL     clra                    ; set to zero
F6B1  8100                            cmpa    #0              ; return EQUAL
F6B3  3586            K_CMP_DONE      puls    D,PC            ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CMD_PROC                                                             *
                      ; *     Parse the command from the line edit buffer.                          *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: Command text within EDT_BUFFER                        *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = search string table index (or $FF if not found)   *
F6B5                  ' *                     X & Y Modified                                        *
                      ; *                     FIO_BUFFER will be modified                           *
                      ; *****************************************************************************
F6B5  BDF6B9          SYS_CMD_PROC    jsr     KRNL_CMD_PROC   ; call the kernel command proc handler
F6B8  3B                              rti                     ; return from the interrupt
                                      ; ...
F6B9  6E9F0026        KRNL_CMD_PROC   jmp     [VEC_CMD_PROC]  ; proceed through the software vector
F6BD  3405            STUB_CMD_PROC   pshs    B,CC            ; save the used registers onto the stack
                                      ; copy EDT_BUFFER to FIO_BUFFER
F6BF  8E0100                          ldx     #EDT_BUFFER     ; the start of the input buffer
F6C2  108E0180                        ldy     #FIO_BUFFER     ; use the I/O buffer temporarily
F6C6  A680            K_CMDP_0        lda     ,x+             ; load a character from the input
F6C8  8141                            cmpa    #'A'            ; make sure input is in lower case
F6CA  2D04                            blt     K_CMDP_3        ;   valid character if < 'A'
F6CC  815A                            cmpa    #'Z'            ; all other characters are good to go
F6CE  2E00                            bgt     K_CMDP_3        ;   valid charcters above 'Z'
                                      * ora   #$20            ; convert all letters to lower case (DONT DO THIS HERE!!!!)
F6D0  A7A0            K_CMDP_3        sta     ,y+             ; copy it to the output
F6D2  26F2                            bne     K_CMDP_0        ; branch until done copying
                                      ; replace the null-terminator with $FF
F6D4  86FF                            lda     #$ff            ; the new character $FF
F6D6  A7A4                            sta     ,y              ; replace the null-terminator
                                      ; replace SPACES with NULL (unless within '' or "")
F6D8  8E0180                          ldx     #FIO_BUFFER     ; the start of the temp buffer
F6DB  A680            K_CMDP_1        lda     ,x+             ; load the next character from buffer
F6DD  2723                            beq     K_CMDP_2
F6DF  81FF                            cmpa    #$FF            ; are we at the end of the buffer?
F6E1  271F                            beq     K_CMDP_2        ;   yes, go parse the buffer
F6E3  8127                            cmpa    #"'"            ; are we at a single-quote character?
F6E5  270C                            beq     K_CPROC_SKIP    ;   skip through until we find another
F6E7  8122                            cmpa    #'"'            ; are we at a double-quote character?
F6E9  2708                            beq     K_CPROC_SKIP    ;   skip through until we find another
F6EB  8120                            cmpa    #' '            ; are we at a SPACE character?
F6ED  26EC                            bne     K_CMDP_1        ; nope, continue scanning       
F6EF  6F1F                            clr     -1,x            ; convert the SPACE to a NULL
F6F1  20E8                            bra     K_CMDP_1        ; continue scanning through the buffer
F6F3  A180            K_CPROC_SKIP    cmpa    ,x+             ; is character a quote character?
F6F5  27E4                            beq     K_CMDP_1        ;    yes, go back to scanning the buffer
F6F7  6D84                            tst     ,x              ; are we at a NULL?
F6F9  26F8                            bne     K_CPROC_SKIP    ;    nope, keep scanning for a quote            
F6FB  BDF4F3                          jsr     KRNL_NEWLINE    ; on error: send a linefeed cleanup
F6FE  86FF                            lda     #$FF            ; error: end of line found but no quote
F700  200E                            bra     K_CPROC_DONE    ; continue looking for a quote character
                                      ; FIO_BUFFER should now be prepared for parsing
F702  860A            K_CMDP_2        lda     #$0a            ; line feed character
F704  BDF4BA                          jsr     KRNL_CHROUT     ; send the line feed
F707  108EF089                        ldy     #KRNL_CMD_TABLE ; point to the command table to search
F70B  8E0180                          ldx     #FIO_BUFFER     ; point to the command to search for
                                      ; X now points to the command to search for in the table
F70E  8D05                            bsr     KRNL_TBLSEARCH  ; seach the table for the command
                                      ; A = index of the found search string table index
F710  3585            K_CPROC_DONE    puls    B,CC,PC         ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_TBLSEARCH                                                            *
                      ; *     Table Search (find the string and return its index)                   *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X points to a string to be searched for               *
                      ; *                     Y points to the start of a string table               *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = string index if found, -1 ($FF) if not found      *
                      ; *                     X = the end of the search string(next argument)       *
                      ; *                         All other registers preserved                     *
                      ; *****************************************************************************
F712  BDF715          SYS_TBLSEARCH   jsr     KRNL_TBLSEARCH  ; call the kernel table search handler
F715  6E9F0028        KRNL_TBLSEARCH  jmp     [VEC_TBLSEARCH] ; proceed through the software vector
F719  3465            STUB_TBLSEARCH  pshs    B,Y,U,CC        ; save the used registers onto the stack
F71B  1F13                            tfr     X,U             ; save X in U
F71D  4F                              clra                    ; set the return index to 0
F71E  1F31            K_TBLS_0        tfr     U,X             ; restore X
F720  BDF684                          jsr     KRNL_CMPSTR     ; compare strings at X and at Y
F723  270E                            beq     K_TBLS_DONE     ; found the string in the table         
F725  4C                              inca                    ; increment the index return value
F726  E6A0            K_TBLS_1        ldb     ,y+             ; look at the next character in table
F728  C1FF                            cmpb    #$ff            ; is it the $ff terminator?
F72A  2705                            beq     K_TBLS_NOTFOUND ; yes, the entry is not in the table
F72C  5D                              tstb                    ; are we looking at a null character?
F72D  26F7                            bne     K_TBLS_1        ; loop until the end of this entry
F72F  20ED                            bra     K_TBLS_0        ; look at the next entry
F731  86FF            K_TBLS_NOTFOUND lda     #$ff            ; not found error code
F733  35E5            K_TBLS_DONE     puls    B,Y,U,CC,PC     ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_CPY_DWORD                                                            *
                      ; *     Copy 32-bits from where X points to where Y points                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X points to a DWORD to be copied from                 *
                      ; *                     Y points to a DWORD to be copied to                   *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:        All registers preserved                           *
                      ; *****************************************************************************
F735  BDF739          SYS_CPY_DWORD   jsr     KRNL_CPY_DWORD  ; call the kernel copy dword handler
F738  3B                              rti                     ; return from the interrupt
                                      ; ...
F739  6E9F002A        KRNL_CPY_DWORD  jmp     [VEC_CPY_DWORD] ; proceed through the software vector
F73D  3407            STUB_CPY_DWORD  pshs    D,CC            ; save the used registers onto the stack
F73F  EC84                            ldd     ,x              ; load the most-significant 16-bit word
F741  EDA4                            std     ,y              ; save the most-significant 16-bit word
F743  EC02                            ldd     2,x             ; load the least-significant 16-bit word
F745  ED22                            std     2,y             ; save the least-significant 16-bit word
F747  3587                            puls    D,CC,PC         ; cleanup saved registers and return
                      
                      ; *******************************************************************************
                      ; * KRNL_D_TO_RAW(A, B, or R)                                                   *
                      ; *     Write the D register to one of the raw float registers                  *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: D = 16-bit value to be written                          *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:        All registers preserved                             *
                      ; *******************************************************************************
F749  BDF74D          SYS_D_TO_RAWA   jsr     KRNL_D_TO_RAWA  ; call the kernel D_TO_RAWA handler
F74C  3B                              rti                     ; return from the interrupt
                                      ; ...
F74D  6E9F002C        KRNL_D_TO_RAWA  jmp     [VEC_D_TO_RAWA] ; proceed through the software vector
F751  3401            STUB_D_TO_RAWA  pshs    CC              ; save the used registers onto the stack
F753  7FFE86                          clr     MATH_ACA_RAW+0  ; clear unneeded byte
F756  7FFE87                          clr     MATH_ACA_RAW+1  ; clear unneeded byte
F759  FDFE88                          std     MATH_ACA_RAW+2  ; store D in the ACA raw float register
F75C  3581                            puls    CC,PC           ; cleanup saved registers and return
                                      
F75E  BDF762          SYS_D_TO_RAWB   jsr     KRNL_D_TO_RAWB  ; call the kernel D_TO_RAWB handler
F761  3B                              rti                     ; return from the interrupt
                                      ; ...
F762  6E9F002E        KRNL_D_TO_RAWB  jmp     [VEC_D_TO_RAWB] ; proceed through the software vector
F766  3401            STUB_D_TO_RAWB  pshs    CC              ; save the used registers onto the stack
F768  7FFE90                          clr     MATH_ACB_RAW+0  ; clear unneeded byte
F76B  7FFE91                          clr     MATH_ACB_RAW+1  ; clear unneeded byte
F76E  FDFE92                          std     MATH_ACB_RAW+2  ; store D in the ACB raw float register
F771  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F773  BDF777          SYS_D_TO_RAWR   jsr     KRNL_D_TO_RAWR  ; call the kernel D_TO_RAWR handler
F776  3B                              rti                     ; return from the interrupt
                                      ; ...
F777  6E9F0030        KRNL_D_TO_RAWR  jmp     [VEC_D_TO_RAWR] ; proceed through the software vector
F77B  3401            STUB_D_TO_RAWR  pshs    CC              ; save the used registers onto the stack
F77D  7FFE9A                          clr     MATH_ACR_RAW+0  ; clear unneeded byte
F780  7FFE9B                          clr     MATH_ACR_RAW+1  ; clear unneeded byte
F783  FDFE9C                          std     MATH_ACR_RAW+2  ; store D in the ACR raw float register
F786  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_D_TO_INT(A, B, or R)                                                 *
                      ; *     Write the D register to one of the FP integer registers               *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: D = 16-bit value to be written                        *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:        All registers preserved                           *
                      ; *****************************************************************************
F788  BDF78C          SYS_D_TO_INTA   jsr     KRNL_D_TO_INTA  ; call the kernel D_TO_INTA handler
F78B  3B                              rti                     ; return from the interrupt
                                      ; ...
F78C  6E9F0032        KRNL_D_TO_INTA  jmp     [VEC_D_TO_INTA] ; proceed through the software vector
F790  3401            STUB_D_TO_INTA  pshs    CC              ; save the used registers onto the stack
F792  7FFE8A                          clr     MATH_ACA_INT+0  ; clear unneeded byte
F795  7FFE8B                          clr     MATH_ACA_INT+1  ; clear unneeded byte
F798  FDFE8C                          std     MATH_ACA_INT+2  ; store D in the ACA integer register
F79B  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F79D  BDF7A1          SYS_D_TO_INTB   jsr     KRNL_D_TO_INTB  ; call the kernel D_TO_INTB handler
F7A0  3B                              rti                     ; return from the interrupt
                                      ; ...           
F7A1  6E9F0034        KRNL_D_TO_INTB  jmp     [VEC_D_TO_INTB] ; proceed through the software vector
F7A5  3401            STUB_D_TO_INTB  pshs    CC              ; save the used registers onto the stack
F7A7  7FFE94                          clr     MATH_ACB_INT+0  ; clear unneeded byte
F7AA  7FFE95                          clr     MATH_ACB_INT+1  ; clear unneeded byte
F7AD  FDFE96                          std     MATH_ACB_INT+2  ; store D in the ACB integer register
F7B0  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F7B2  BDF7B6          SYS_D_TO_INTR   jsr     KRNL_D_TO_INTR  ; call the kernel D_TO_INTR handler
F7B5  3B                              rti                     ; return from the interrupt
                                      ; ...
F7B6  6E9F0036        KRNL_D_TO_INTR  jmp     [VEC_D_TO_INTR] ; proceed through the software vector
F7BA  3401            STUB_D_TO_INTR  pshs    CC              ; save the used registers onto the stack
F7BC  7FFE9E                          clr     MATH_ACR_INT+0  ; clear unneeded byte
F7BF  7FFE9F                          clr     MATH_ACR_INT+1  ; clear unneeded byte
F7C2  FDFEA0                          std     MATH_ACR_INT+2  ; store D in the ACR integer register
F7C5  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
                      ; *******************************************************************************
                      ; * KRNL_RAW(A, B, or R)_TO_D                                                   *
                      ; *     Read one of the raw float registers into the D register                 *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: none                                                    *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS: D = the integer value of the chosen FP register            *
                      ; *                         All other registers preserved                       *
                      ; *                                                                             *
                      ; *******************************************************************************
F7C7  BDF7CB          SYS_RAWA_TO_D   jsr     KRNL_RAWA_TO_D  ; call the kernel RAWA_TO_D handler
F7CA  3B                              rti                     ; return from the interrupt
                                      ; ...
F7CB  6E9F0038        KRNL_RAWA_TO_D  jmp     [VEC_RAWA_TO_D] ; proceed through the software vector
F7CF  3401            STUB_RAWA_TO_D  pshs    CC              ; save the used registers onto the stack
F7D1  FCFE88                          ldd     MATH_ACA_RAW+2  ; load the ACA raw float value
F7D4  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F7D6  BDF7DA          SYS_RAWB_TO_D   jsr     KRNL_RAWB_TO_D  ; call the kernel RAWB_TO_D handler
F7D9  3B                              rti                     ; return from the interrupt
                                      ; ...
F7DA  6E9F003A        KRNL_RAWB_TO_D  jmp     [VEC_RAWB_TO_D] ; proceed through the software vector
F7DE  3401            STUB_RAWB_TO_D  pshs    CC              ; save the used registers onto the stack
F7E0  FCFE92                          ldd     MATH_ACB_RAW+2  ; load the ACB raw float value
F7E3  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F7E5  BDF7E9          SYS_RAWR_TO_D   jsr     KRNL_RAWR_TO_D  ; call the kernel RAWR_TO_D handler
F7E8  3B                              rti                     ; return from the interrupt
                                      ; ...
F7E9  6E9F003C        KRNL_RAWR_TO_D  jmp     [VEC_RAWR_TO_D] ; proceed through the software vector
F7ED  3401            STUB_RAWR_TO_D  pshs    CC              ; save the used registers onto the stack
F7EF  FCFE9C                          ldd     MATH_ACR_RAW+2  ; load the ACR raw float value
F7F2  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
                      
                      ; *******************************************************************************
                      ; * KRNL_INT(A, B, or R)_TO_D                                                   *
                      ; *     Read one of the integer registers into the D register                   *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: none                                                    *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS: D = the integer value of the chosen FP register            *
                      ; *                         All other registers preserved                       *
                      ; *                                                                             *
                      ; *******************************************************************************
F7F4  BDF7F8          SYS_INTA_TO_D   jsr     KRNL_INTA_TO_D  ; call the kernel INTA_TO_D handler
F7F7  3B                              rti                     ; return from the interrupt
                                      ; ...
F7F8  6E9F003E        KRNL_INTA_TO_D  jmp     [VEC_INTA_TO_D] ; proceed through the software vector
F7FC  3401            STUB_INTA_TO_D  pshs    CC              ; save the used registers onto the stack
F7FE  FCFE8C                          ldd     MATH_ACA_INT+2  ; load the ACA integer value
F801  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F803  BDF807          SYS_INTB_TO_D   jsr     KRNL_INTB_TO_D  ; call the kernel INTB_TO_D handler
F806  3B                              rti                     ; return from the interrupt
                                      ; ...
F807  6E9F0040        KRNL_INTB_TO_D  jmp     [VEC_INTB_TO_D] ; proceed through the software vector
F80B  3401            STUB_INTB_TO_D  pshs    CC              ; save the used registers onto the stack
F80D  FCFE96                          ldd     MATH_ACB_INT+2  ; load the ACB integer value
F810  3581                            puls    CC,PC           ; cleanup saved registers and return
                      
F812  BDF816          SYS_INTR_TO_D   jsr     KRNL_INTR_TO_D  ; call the kernel INTR_TO_D handler
F815  3B                              rti                     ; return from the interrupt
                                      ; ...
F816  6E9F0042        KRNL_INTR_TO_D  jmp     [VEC_INTR_TO_D] ; proceed through the software vector
F81A  3401            STUB_INTR_TO_D  pshs    CC              ; save the used registers onto the stack
F81C  FCFEA0                          ldd     MATH_ACR_INT+2  ; load the ACR integer value
F81F  3581                            puls    CC,PC            cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_8BIT_MATH                                                            *
                      ; *     8-bit integer math                                                    *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: A = ACA Integer                                       *
                      ; *                     B = ACB Integer                                       *
                      ; *                     U = Math Operation (MOP)                              *
                      ; *                         (only least significant byte is relevant)         *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    D = Result                                            *
                      ; *                     All other registers preserved                         *
                      ; *****************************************************************************
F821  BDF825          SYS_8BIT_MATH   jsr     KRNL_8BIT_MATH  ; call the kernel 8BIT_MATH handler
F824  3B                              rti                     ; return from the interrupt
                                      ; ...
F825  6E9F0044        KRNL_8BIT_MATH  jmp     [VEC_8BIT_MATH] ; proceed through the software vector
F829  3441            STUB_8BIT_MATH  pshs    U,CC            ; save the used registers onto the stack
                                      ; A to ACA
F82B  7FFE8A                          clr     MATH_ACA_INT+0  ; clear unneeded byte
F82E  7FFE8B                          clr     MATH_ACA_INT+1  ; clear unneeded byte
F831  7FFE8C                          clr     MATH_ACA_INT+2  ; clear unneeded byte
F834  B7FE8D                          sta     MATH_ACA_INT+3  ; store A in the ACA integer register
                                      ; B to ACB
F837  7FFE94                          clr     MATH_ACB_INT+0  ; clear unneeded byte
F83A  7FFE95                          clr     MATH_ACB_INT+1  ; clear unneeded byte
F83D  7FFE96                          clr     MATH_ACB_INT+2  ; clear unneeded byte
F840  F7FE97                          stb     MATH_ACB_INT+3  ; store B in the ACB integer register
                                      ; U to MATH_OPERATION
F843  1F30                            tfr     U,D             ; transfer the MOP instruction to D
F845  F7FEA2                          stb     MATH_OPERATION  ; send the MOP command (in B)
                                      ; ACR to D
F848  FCFEA0                          ldd     MATH_ACR_INT+2  ; load the result into the D register
F84B  35C1                            puls    U,CC,PC         ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_DSP_AC(A, B, or R)                                                   *
                      ; *     Displays the floating point number in one of the FP registers.        *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: none                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F84D  BDF851          SYS_DSP_ACA     jsr     KRNL_DSP_ACA    ; call the kernel DSP_ACA handler
F850  3B                              rti                     ; return from the interrupt
                                      ; ...
F851  6E9F0046        KRNL_DSP_ACA    jmp     [VEC_DSP_ACA]   ; proceed through the software vector
F855  3411            STUB_DSP_ACA    pshs    X,CC            ; save the used registers onto the stack
F857  8EFE84                          ldx     #MATH_ACA_POS   ; index the ACA data
F85A  8D24                            bsr     KRNL_DSP_HELPER ; display the floating point of ACA
F85C  3591                            puls    X,CC,PC         ; cleanup saved registers and return
                      
F85E  BDF862          SYS_DSP_ACB     jsr     KRNL_DSP_ACB    ; call the kernel DSP_ACB handler
F861  3B                              rti                     ; return from the interrupt
                                      ; ...
F862  6E9F0048        KRNL_DSP_ACB    jmp     [VEC_DSP_ACB]    proceed through the software vector
F866  3411            STUB_DSP_ACB    pshs    X,CC            ; save the used registers onto the stack
F868  8EFE8E                          ldx     #MATH_ACB_POS   ; index the ACB data
F86B  8D13                            bsr     KRNL_DSP_HELPER ; display the floating point of ACB
F86D  3591                            puls    X,CC,PC         ; cleanup saved registers and return
                      
F86F  BDF873          SYS_DSP_ACR     jsr     KRNL_DSP_ACR    ; call the kernel DSP_ACR handler
F872  3B                              rti                     ; return from the interrupt
                                      ; ...
F873  6E9F004A        KRNL_DSP_ACR    jmp     [VEC_DSP_ACR]   ; proceed through the software vector
F877  3411            STUB_DSP_ACR    pshs    X,CC            ; save the used registers onto the stack
F879  8EFE98                          ldx     #MATH_ACR_POS   ; index the ACR data
F87C  8D02                            bsr     KRNL_DSP_HELPER ; display the floating point of ACR
F87E  3591                            puls    X,CC,PC         ; cleanup saved registers and return
                      
                      ;HELPER:  X=address of a FP_POS register pointed to by X
F880  3403            KRNL_DSP_HELPER pshs    A,CC            ; save the used registers onto the stack
F882  6F84                            clr     ,x              ; reset this math data port
F884  A601            K_DSP_FP_0      lda     1,x             ; pop a character from the port
F886  BDF4BA                          jsr     KRNL_CHROUT     ; send it to the console
F889  26F9                            bne     K_DSP_FP_0      ; continue if not at the null-terminator
F88B  3583                            puls    A,CC,PC         ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_DSP_INT(A, B, or R)                                                  *
                      ; *     Displays the integer number in one of the FP registers.               *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: none                                                  *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; ***************************************************************************** 
F88D  BDF891          SYS_DSP_INTA    jsr     KRNL_DSP_INTA   ; call the kernel DSP_INTA handler
F890  3B                              rti                     ; return from the interrupt
                                      ; ...   
F891  6E9F004C        KRNL_DSP_INTA   jmp     [VEC_DSP_INTA]  ; proceed through the software vector
F895  3411            STUB_DSP_INTA   pshs    X,CC            ; save the used register onto the stack
F897  8EFE84                          ldx     #MATH_ACA_POS   ; index the ACA data
F89A  8D24                            bsr     KRNL_DSP_IHELP  ; display the integer portion of ACA
F89C  3591                            puls    X,CC,PC         ; cleanup and return
                      
F89E  BDF8A2          SYS_DSP_INTB    jsr     KRNL_DSP_INTB   ; call the kernel DSP_INTB handler
F8A1  3B                              rti                     ; return from the interrupt
                                      ; ...   
F8A2  6E9F004E        KRNL_DSP_INTB   jmp     [VEC_DSP_INTB]  ; proceed through the software vector
F8A6  3411            STUB_DSP_INTB   pshs    X,CC            ; save the used register onto the stack
F8A8  8EFE84                          ldx     #MATH_ACA_POS   ; index the ACB data
F8AB  8D13                            bsr     KRNL_DSP_IHELP  ; display the integer portion of ACB
F8AD  3591                            puls    X,CC,PC         ; cleanup and return
                      
F8AF  BDF8B3          SYS_DSP_INTR    jsr     KRNL_DSP_INTR   ; call the kernel DSP_INTR handler
F8B2  3B                              rti                     ; return from the interrupt
                                      ; ...   
F8B3  6E9F0050        KRNL_DSP_INTR   jmp     [VEC_DSP_INTR]  ; proceed through the software vector
F8B7  3411            STUB_DSP_INTR   pshs    X,CC            ; save the used register onto the stack
F8B9  8EFE98                          ldx     #MATH_ACR_POS   ; index the ACR data
F8BC  8D02                            bsr     KRNL_DSP_IHELP  ; display the integer portion of ACR
F8BE  3591                            puls    X,CC,PC         ; cleanup and return
                      
                      ;HELPER:  X=address of a FP_POS register pointed to by X. Display Integer
F8C0  3403            KRNL_DSP_IHELP  pshs    A,CC            ; save the used registers onto the stack
F8C2  6F84                            clr     ,x              ; reset this math data port
F8C4  A601            K_DSP_INT_0     lda     1,x             ; pop a character from the port
F8C6  812E                            cmpa    #'.'            ; is it the decimal point?
F8C8  2706                            beq     K_DSP_INT_RET   ;   yeah, we're done
F8CA  BDF4BA                          jsr     KRNL_CHROUT     ; no, output to the console
F8CD  4D                              tsta                    ; are we at the null-terminator?
F8CE  26F4                            bne     K_DSP_INT_0     ;   no, continue looping
F8D0  3583            K_DSP_INT_RET   puls    A,CC,PC         ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_WRITE_AC(A, B, or R)                                                 *
                      ; *     Sets one of the floating point registers to a FP value contained      *
                      ; *     within a null-terminated string pointed to by X.                      *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X = points to a null-terminated string of numbers     *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    All registers preserved                               *
                      ; *****************************************************************************
F8D2  BDF8D6          SYS_WRITE_ACA   jsr     KRNL_WRITE_ACA  ; call the kernel WRITE_ACA handler
F8D5  3B                              rti                     ; return from the interrupt
                                      ; ...
F8D6  6E9F0052        KRNL_WRITE_ACA  jmp     [VEC_WRITE_ACA] ; proceed through the software vector
F8DA  3431            STUB_WRITE_ACA  pshs    X,Y,CC          ; save the used registers onto the stack
F8DC  108EFE84                        ldy     #MATH_ACA_POS   ; point to the ACA chr pos register
F8E0  8D26                            bsr     KRNL_WRITE_HLP  ; display the number to the console
F8E2  35B1                            puls    X,Y,CC,PC       ; cleanup saved registers and return
                      
F8E4  BDF8E8          SYS_WRITE_ACB   jsr     KRNL_WRITE_ACB  ; call the kernel WRITE_ACB handler
F8E7  3B                              rti                     ; return from the interrupt
                                      ; ...
F8E8  6E9F0054        KRNL_WRITE_ACB  jmp     [VEC_WRITE_ACB] ; proceed through the software vector
F8EC  3431            STUB_WRITE_ACB  pshs    X,Y,CC          ; save the used registers onto the stack
F8EE  108EFE8E                        ldy     #MATH_ACB_POS   ; point to the ACB chr pos register
F8F2  8D14                            bsr     KRNL_WRITE_HLP  ; display the number to the console
F8F4  35B1                            puls    X,Y,CC,PC       ; cleanup saved registers and return
                      
F8F6  BDF8FA          SYS_WRITE_ACR   jsr     KRNL_WRITE_ACR  ; call the kernel WRITE_ACR handler
F8F9  3B                              rti                     ; return from the interrupt
                                      ; ...
F8FA  6E9F0056        KRNL_WRITE_ACR  jmp     [VEC_WRITE_ACR] ; proceed through the software vector
F8FE  3431            STUB_WRITE_ACR  pshs    X,Y,CC          ; save the used registers onto the stack
F900  108EFE98                        ldy     #MATH_ACR_POS   ; point to the ACR chr pos register
F904  8D02                            bsr     KRNL_WRITE_HLP  ; display the number to the console
F906  35B1                            puls    X,Y,CC,PC       ; cleanup saved registers and return    
                      
                      ; X string to write, Y = ACn_POS
F908  3431            KRNL_WRITE_HLP  pshs    X,Y,CC          ; save the used registers onto the stack
F90A  6FA0                            clr     ,y+             ; set the chr pos to the start
F90C  A680            KRNL_WRITE_0    lda     ,x+             ; load the next char from the string
F90E  2704                            beq     KRNL_WRITE_DONE ; were done if it's a null-terminator
F910  A7A4                            sta     ,y              ; store the char into the FP port
F912  20F8                            bra     KRNL_WRITE_0    ; continue looping
F914  35B1            KRNL_WRITE_DONE puls    X,Y,CC,PC       ; cleanup saved registers and return
                      
                      
                      ; *****************************************************************************
                      ; * KRNL_ARG_TO_A                                                             *
                      ; *     convert a numeric string (pointed to by X) to 0-25 and return it in A *
                      ; *                                                                           *
                      ; * ENTRY REQUIREMENTS: X = points to the string to be converted              *
                      ; *                         Note: hex values must be preceeded                *
                      ; *                               with a '$' character                        *
                      ; *                                                                           *
                      ; * EXIT CONDITIONS:    A = binary value represented by the input string      *
                      ; *                     All other registers preserved                         *
                      ; *****************************************************************************
F916  BDF91A          SYS_ARG_TO_A    jsr     KRNL_ARG_TO_A   ; call the kernel ARG_TO_A handler
F919  3B                              rti                     ; return from the interrupt
                      
F91A  6E9F0058        KRNL_ARG_TO_A   jmp     [VEC_ARG_TO_A]  ; proceed through the software vector
F91E  3415            STUB_ARG_TO_A   pshs    B,X,CC          ; save the used registers onto the stack
F920  E684                            ldb     ,x              ; load character to be converted
F922  C124                            cmpb    #'$'            ; is it the leading '$'?
F924  2708                            beq     KARG_0          ;   yeah, go convert from hexidecimal
F926  BDF8D6                          jsr     KRNL_WRITE_ACA  ; use the FP to convert from decimal
F929  B6FE8D                          lda     MATH_ACA_INT+3  ; load the converted binary into A
F92C  2012                            bra     KARG_DONE       ;   A now holds the binary, return
F92E  3001            KARG_0          leax    1,x             ; skip passed the initial '$' character
F930  E680                            ldb     ,x+             ; load character to convert into B
F932  8D0E                            bsr     KARG_HEX        ; convert hex character to 0-15 binary
F934  58                              lslb                    ; shift the 4-bit data ... 
F935  58                              lslb                    ; ... into the most significant ...
F936  58                              lslb                    ; ... four-bits
F937  58                              lslb                    ; $n0 n = useful value
F938  3404                            pshs    b               ; save our work so far
F93A  E680                            ldb     ,x+             ; load the next hex character
F93C  8D04                            bsr     KARG_HEX        ; decode it to 0-15
F93E  AAE0                            ora     ,s+             ; merge the two and fix the stack
F940  3595            KARG_DONE       puls    B,X,CC,PC       ; clean up and return
                                      ; helper sub
F942  3404            KARG_HEX        pshs    b               ; save it 
F944  C030                            subb    #'0'            ; convert to binary
F946  2B0C                            bmi     2f              ; go if not numeric
F948  C109                            cmpb    #$09            ; is greater than 9?
F94A  2304                            bls     1f              ; branch if not
F94C  CA20                            orb     #$20            ; to lower case
F94E  C027                            subb    #$27            ; reduce from 'a'
F950  C10F            1               cmpb    #$0f            ; greater than 15?
F952  2302                            bls     3f              ; go if not
F954  C6FF            2               ldb     #$ff            ; load an error state $FF = BAD
F956  E1E0            3               cmpb    ,s+             ; fix the stack
F958  1F98                            tfr     b,a             ; restore into A
F95A  39                              rts                     ; return
                      
                      
                      
                      ; *******************************************************************************
                      ; * SUBROUTINE_TEMPLATE                                                         *
                      ; *     xxxxxxxxxxxxxxxxxx                                                      *
                      ; *                                                                             *
                      ; * ENTRY REQUIREMENTS: A = xxxxxxxxxxx                                         *
                      ; *                     B = xxxxxxxxxxx                                         *
                      ; *                                                                             *
                      ; * EXIT CONDITIONS:    D = Result                                              *
                      ; * EXIT CONDITIONS:    All registers preserved                                 *
                      ; *                     All other registers preserved                           *
                      ; *******************************************************************************
                      
                      
                      
                      
                      
                      
                      * ; *****************************************************************************
                      * ; * ROM BASED HARDWARE VECTORS                                                *
                      * ; *****************************************************************************
FFF0                                  org     ROM_VECTS_DEVICE
FFF0                  KRNL_HARD_VECT                  
FFF0  F1CC                            fdb     EXEC_start      ; (HARD_RSRVD) EXEC Interrupt Vector
FFF2  F1CD                            fdb     SWI3_start      ; (HARD_SWI3 ) SWI3 Hardware Interrupt Vector
FFF4  F460                            fdb     SYS_Handler     ; (HARD_SWI2 ) SWI2 Hardware Interrupt Vector
FFF6  F1D3                            fdb     FIRQ_start      ; (HARD_FIRQ ) FIRQ Hardware Interrupt Vector
FFF8  F1D6                            fdb     IRQ_start       ; (HARD_IRQ  ) IRQ Hardware Interrupt Vector
FFFA  F1D9                            fdb     SWI_start       ; (HARD_SWI  ) SWI / SYS Hardware Interrupt Vector
FFFC  F1DC                            fdb     NMI_start       ; (HARD_NMI  ) NMI Hardware Interrupt Vector
FFFE  F000                            fdb     KRNL_START      ; (HARD_RESET) RESET Hardware Interrupt Vector
0000                  KRNL_HARD_VECT_END
