typedef std::pair<Word, Word> MemoryRange;

struct DeviceNode {
    Device* pDevice;
    MemoryRange range;
};

// In your Memory class
struct std::hash<MemoryRange> {
    size_t operator()(const MemoryRange& r) const noexcept {
        return std::hash<Word>{}(r.first) ^ std::hash<Word>{}(r.second);
    }
};

std::unordered_map<MemoryRange, DeviceNode*> _memory_nodes;

// In the Attach() method of your Memory class
template <typename T>
bool Memory::Attach(uint32_t addr)
{
    std::cout << clr::indent_push() << clr::CYAN << "Memory::Attach<T>(addr, type=0x" << std::hex << (int)type << ", addr=0x" << std::hex << addr << " Entry" << clr::RETURN;
    auto dev = new T(this);
    dev->SetAddr(addr);

    MemoryRange range{addr, addr + sizeof(T)};

    if (!_attachDevice(range, {dev, range}))
    {
        std::cout << clr::indent_pop() << clr::ORANGE << "Memory::Attach<T>(addr, type=0x" << std::hex << (int)type << ", addr=0x" << std::hex << addr << " Error" << clr::RETURN;
        delete dev;
        return false;
    }
    std::cout << clr::indent_pop() << clr::CYAN << "Memory::Attach<T>(addr, type=0x" << std::hex << (int)type << ", addr=0x" << std::hex << addr << " Exit" << clr::RETURN;
    return true;
}

bool Memory::OnInit()
{
    std::cout << clr::indent_push() << clr::CYAN << "Memory::OnInit() Entry" << clr::RETURN;
    for (auto& node : _memory_nodes)
    {
        if (!node.second->pDevice->OnInit())
        {
            std::cout << clr::indent_pop() << clr::ORANGE << "Memory::OnInit() Error" << clr::RETURN;
            return false;
        }
    }
    std::cout << clr::indent_pop() << clr::CYAN << "Memory::OnInit() Exit" << clr::RETURN;
    return true;
}

Byte Memory::Read(Word offset, bool debug)
{
    auto It = _memory_nodes.find({offset, offset});
    if (It != _memory_nodes.end())
    {
        if (debug)
            return It->second->pDevice->OnRead(offset);
        return It->second->pDevice->memory[offset - It->second->range.first];
    }
    return 0xCC;
}

void Memory::Write(Word offset, Byte data, bool debug)
{
    auto It = _memory_nodes.find({offset, offset});
    if (It != _memory_nodes.end())
    {
        ROM* IsROM = dynamic_cast<ROM*>(It->second->pDevice);
        if (debug && IsROM)
            IsROM->write_to_rom(offset, data);
        else
            It->second->pDevice->memory[offset - It->second->range.first] = data;
    }
}
